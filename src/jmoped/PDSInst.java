package jmoped;

import java.util.Arrays;
import java.util.Collection;
import java.util.Enumeration;
import java.util.List;
import java.util.ArrayList;

import javax.swing.tree.DefaultMutableTreeNode;

import org.apache.log4j.Logger;
import org.gjt.jclasslib.bytecode.AbstractInstruction;
import org.gjt.jclasslib.bytecode.BranchInstruction;
import org.gjt.jclasslib.bytecode.ImmediateByteInstruction;
import org.gjt.jclasslib.bytecode.ImmediateShortInstruction;
import org.gjt.jclasslib.bytecode.IncrementInstruction;
import org.gjt.jclasslib.bytecode.InvokeInterfaceInstruction;
import org.gjt.jclasslib.bytecode.LookupSwitchInstruction;
import org.gjt.jclasslib.bytecode.MatchOffsetPair;
import org.gjt.jclasslib.bytecode.MultianewarrayInstruction;
import org.gjt.jclasslib.bytecode.Opcodes;
import org.gjt.jclasslib.bytecode.TableSwitchInstruction;
import org.gjt.jclasslib.structures.AccessFlags;
import org.gjt.jclasslib.structures.CPInfo;
import org.gjt.jclasslib.structures.ClassFile;
import org.gjt.jclasslib.structures.InvalidByteCodeException;
import org.gjt.jclasslib.structures.constants.ConstantClassInfo;
import org.gjt.jclasslib.structures.constants.ConstantIntegerInfo;
import org.gjt.jclasslib.structures.constants.ConstantInterfaceMethodrefInfo;
import org.gjt.jclasslib.structures.constants.ConstantNameAndTypeInfo;
import org.gjt.jclasslib.structures.constants.ConstantReference;

import jmoped.PDSInfo.ClassNode;

import static jmoped.PDSInfo.HeapOption;
import jmoped.policygen.FieldStruct;//by suncong
//import jmoped.policygen.Low;

public class PDSInst {
	
	/**
	 * Represents type of bytecode instructions that are not supported
	 * by jMoped
	 */
	public static enum Warning { BITWISE, FLOAT, DOUBLE, NEGATIVE, STRING }
	
	private AbstractInstruction absInst = null;
	private PDSMethod pdsMethod;
	private PDSInfo pdsInfo;
	private PDSStmt pdsStmt;
	private List<Warning> warningList = new ArrayList<Warning>();
	
	/**
	 * Marks if this instruction was replaced from the outside. 
	 * If this is the case, the Remopla output will not be rebuilt 
	 * in {@link #toRemopla()} and the actual 
	 * underlying bytecode instruction will be ignored.
	 */
	private boolean instReplaced = false;
	

	
	static Logger logger = Logger.getLogger(PDSInst.class);

	public PDSInst(PDSMethod pdsMethod, AbstractInstruction absInst, PDSInfo pdsInfo)
		throws InvalidByteCodeException {
		
		this.pdsMethod = pdsMethod;
		this.absInst = absInst;
		this.pdsInfo = pdsInfo;
		pdsStmt = new PDSStmt();
	}
	
	/*************
	 *by suncong, for not displaying pair remopla instruction in initialMethodWrapper*/
	private boolean toRemPair=true;
	
	public PDSInst(PDSMethod pdsMethod, AbstractInstruction absInst, PDSInfo pdsInfo, boolean rem_pair)
		throws InvalidByteCodeException {
		
		this.pdsMethod = pdsMethod;
		this.absInst = absInst;
		this.pdsInfo = pdsInfo;
		pdsStmt = new PDSStmt();
		toRemPair=rem_pair;
	}
	
	public boolean getToRemPair(){
		return toRemPair;
	}
	/* by suncong, record the count of low indices added to array 'lowidx' by instruction 'new'*/
/*	private int low_cnt_by_inst_new=-1;
	
	public void setNewedLowCount(int cnt){
		low_cnt_by_inst_new=cnt;
	}
	
	public int getNewedLowCount(){
		return low_cnt_by_inst_new;
	}*/
	
	/*this method can only used on the instructions generated by initialMethodWrapper*/
	public void setOffsetForAbstractInst(int abs_offset){
		absInst.setOffset(abs_offset);
	}
	
	public int getOffsetFromAbstractInst(){
		return absInst.getOffset();
	}
	/***************************************************************************/
	
	public PDSInst(PDSMethod pdsMethod, PDSInfo pdsInfo) {
		
		this.pdsMethod = pdsMethod;
		this.pdsInfo = pdsInfo;
		pdsStmt = new PDSStmt();
	}
	
	public void addInst(String stmt, String stmt_pair) {
		pdsStmt.addPar(stmt,stmt_pair);
	}
	
	public void replaceInst(String st,String st_pair) {
		pdsStmt = new PDSStmt();
		pdsStmt.addNext(st,st_pair);
		instReplaced = true;
	}
	
	public String toRemopla() throws InvalidByteCodeException {
		
		StringBuilder out = new StringBuilder();

		out.append(getLabel(false));
		out.append(":\t");
		out.append(pdsStmt.toRemopla());
		
		return out.toString();
	}
	/*added by suncong*/
	public String toRemoplaPair() throws InvalidByteCodeException {
		StringBuilder out = new StringBuilder();

		out.append(getLabel(true)).append(":\t");
		out.append(pdsStmt.toRemoplaPair());
		
		return out.toString();
	}
	/*****************/

/*added by suncong, for same use as the method of PDSInstOld, for discarding PDSInstOld*/
	public AbstractInstruction getInstruction()
	{
		return absInst;
	}
	public PDSInfo getPDSInfo(){
		return this.pdsInfo;
	}
	public PDSMethod getPDSMethod(){
		return this.pdsMethod;
	}
/*************************/
	
	/**
	 * Returns the label for this instruction.
	 * <p>
	 * If the pc offset in the method is large than 0, it is appended, otherwise just
	 * the formatted method name is returned.
	 */
	private String getLabel(boolean bPair) {
		
		StringBuilder builder = bPair? 
			new StringBuilder(pdsInfo.generatePairLabel(pdsMethod.getFormattedName(),"")): 
			new StringBuilder(pdsMethod.getFormattedName());
		if ((absInst != null) && absInst.getOffset() > 0) {
			builder.append(absInst.getOffset());
		}
		return builder.toString();
	}
	/*added by suncong*/
/*	private String getLabelPair(){
		StringBuilder builder = new StringBuilder(pdsInfo.generatePairLabel(pdsMethod.getFormattedName(),""));
		if ((absInst != null) && absInst.getOffset() > 0) {
			builder.append(absInst.getOffset());
		}
		return builder.toString();	
	}*/
	/*****************/
	
	public List<Warning> getWarningList() {
		
		return warningList;
	}
	
	public void translate() throws InvalidByteCodeException {
		
		if (absInst == null || instReplaced)
			return;
		
		switch (absInst.getOpcode()) {
		
		case Opcodes.OPCODE_AALOAD: 
			aaloadInst();
			break;
		case Opcodes.OPCODE_AASTORE:
			aastoreInst();
			break;
		case Opcodes.OPCODE_ACONST_NULL: 
			pushWithInst(0);
			break;
		case Opcodes.OPCODE_ALOAD: 
			pushWithInst(pdsInfo.varIndex(immediateByte()),pdsInfo.varIndex(immediateByte()));
			break;
		case Opcodes.OPCODE_ALOAD_0: 
		case Opcodes.OPCODE_ALOAD_1: 
		case Opcodes.OPCODE_ALOAD_2: 
		case Opcodes.OPCODE_ALOAD_3: 
			pushWithInst(pdsInfo.varIndex(absInst.getOpcode() - Opcodes.OPCODE_ALOAD_0),
						pdsInfo.varIndex(absInst.getOpcode() - Opcodes.OPCODE_ALOAD_0));
			break;
		case Opcodes.OPCODE_ANEWARRAY:
			anewarrayInst();
			break;
		case Opcodes.OPCODE_ARETURN:
			oneInst("return " + pdsInfo.stackIndex(0), "return "+pdsInfo.stackIndex(0));
			break;
		case Opcodes.OPCODE_ARRAYLENGTH: 
			arraylengthInst();
			break;
		case Opcodes.OPCODE_ASTORE:
			popToInst(pdsInfo.varIndex(immediateByte()),pdsInfo.varIndex(immediateByte()));
			break;
		case Opcodes.OPCODE_ASTORE_0: 
		case Opcodes.OPCODE_ASTORE_1: 
		case Opcodes.OPCODE_ASTORE_2: 
		case Opcodes.OPCODE_ASTORE_3:
			popToInst(pdsInfo.varIndex(absInst.getOpcode() - Opcodes.OPCODE_ASTORE_0),
					pdsInfo.varIndex(absInst.getOpcode() - Opcodes.OPCODE_ASTORE_0));
			break;
		case Opcodes.OPCODE_ATHROW: 
			// TODO 
			// actually handling exceptions would mean to go through the
			// call stack and look for possible exception handlers. To
			// avoid spurious executions we go to an extra general
			// exception state for now
			oneInst(gotoStmt(pdsInfo.getLabelGeneralException()), gotoStmt(pdsInfo.getLabelGeneralException()));
			break;
		case Opcodes.OPCODE_BALOAD: 
			ialoadInst();
			break;
		case Opcodes.OPCODE_BASTORE:
			iastoreInst();
			break;
		case Opcodes.OPCODE_BIPUSH: 
			pushWithInst(immediateByte());
			break;
		case Opcodes.OPCODE_CALOAD: 
			ialoadInst();
			break;
		case Opcodes.OPCODE_CASTORE:
			iastoreInst();
			break;
		case Opcodes.OPCODE_CHECKCAST: 
			//TODO
			oneInst("skip","skip");
			break;
		case Opcodes.OPCODE_DADD:
			warningList.add(Warning.DOUBLE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_DALOAD:
			warningList.add(Warning.DOUBLE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_DASTORE:
			warningList.add(Warning.DOUBLE);
			popPushInst("undef","undef", 3, 0);
			break;
		case Opcodes.OPCODE_DCMPG:
		case Opcodes.OPCODE_DCMPL:
			warningList.add(Warning.DOUBLE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_DCONST_0: 
		case Opcodes.OPCODE_DCONST_1:
			warningList.add(Warning.DOUBLE);
			pushWithInst(absInst.getOpcode() - Opcodes.OPCODE_DCONST_0);
			break;
		case Opcodes.OPCODE_DDIV:
			warningList.add(Warning.DOUBLE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_DLOAD: 
		case Opcodes.OPCODE_DLOAD_0: 
		case Opcodes.OPCODE_DLOAD_1: 
		case Opcodes.OPCODE_DLOAD_2: 
		case Opcodes.OPCODE_DLOAD_3:
			warningList.add(Warning.DOUBLE);
			pushWithInst("undef","undef");
			break;
		case Opcodes.OPCODE_DMUL:
			warningList.add(Warning.DOUBLE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_DNEG:
			warningList.add(Warning.DOUBLE);
			warningList.add(Warning.NEGATIVE);
			popPushInst("undef","undef", 1, 1);
			break;
		case Opcodes.OPCODE_DREM:
			warningList.add(Warning.DOUBLE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_DRETURN:
			warningList.add(Warning.DOUBLE);
			oneInst("return " + pdsInfo.stackIndex(0), "return "+pdsInfo.stackIndex(0));
			break;
		case Opcodes.OPCODE_DSTORE: 
		case Opcodes.OPCODE_DSTORE_0: 
		case Opcodes.OPCODE_DSTORE_1: 
		case Opcodes.OPCODE_DSTORE_2: 
		case Opcodes.OPCODE_DSTORE_3:
			warningList.add(Warning.DOUBLE);
			popPushInst("undef","undef", 1, 0);
			break;
		case Opcodes.OPCODE_DSUB:
			warningList.add(Warning.DOUBLE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_DUP: 
			pushWithInst(pdsInfo.stackIndex(0), pdsInfo.stackIndex(0));
			break;
		case Opcodes.OPCODE_DUP_X1:
			pdsStmt.addPar(stackEqual(0, 0), stackEqual(0,0));
			pdsStmt.addPar(stackEqual(1, 1), stackEqual(1,1));
			pdsStmt.addPar(stackEqual(2, 0), stackEqual(2,0));
			pdsStmt.addPar(pushStmt(3, 1), pushStmt(3,1));
			break;
		case Opcodes.OPCODE_DUP_X2:
			pdsStmt.addPar(stackEqual(0, 0), stackEqual(0,0));
			pdsStmt.addPar(stackEqual(1, 1), stackEqual(1,1));
			pdsStmt.addPar(stackEqual(2, 2), stackEqual(2,2));
			pdsStmt.addPar(stackEqual(3, 0), stackEqual(3,0));
			pdsStmt.addPar(pushStmt(4, 1), pushStmt(4,1));
			break;
		case Opcodes.OPCODE_DUP2:
			pdsStmt.addPar(stackEqual(0, 0), stackEqual(0,0));
			pdsStmt.addPar(stackEqual(1, 1), stackEqual(1,1));
			pdsStmt.addPar(stackEqual(2, 0), stackEqual(2,0));
			pdsStmt.addPar(stackEqual(3, 1), stackEqual(3,1));
			pdsStmt.addPar(pushStmt(4, 1), pushStmt(4,1));
		case Opcodes.OPCODE_FADD:
			warningList.add(Warning.FLOAT);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_FALOAD:
			warningList.add(Warning.FLOAT);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_FASTORE:
			warningList.add(Warning.FLOAT);
			popPushInst("undef","undef", 3, 0);
			break;
		case Opcodes.OPCODE_FCMPG: 
		case Opcodes.OPCODE_FCMPL:
			warningList.add(Warning.FLOAT);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_FCONST_0: 
		case Opcodes.OPCODE_FCONST_1: 
		case Opcodes.OPCODE_FCONST_2:
			warningList.add(Warning.FLOAT);
			pushWithInst(absInst.getOpcode() - Opcodes.OPCODE_FCONST_0);
			break;
		case Opcodes.OPCODE_FDIV:
			warningList.add(Warning.FLOAT);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_FLOAD: 
		case Opcodes.OPCODE_FLOAD_0: 
		case Opcodes.OPCODE_FLOAD_1: 
		case Opcodes.OPCODE_FLOAD_2: 
		case Opcodes.OPCODE_FLOAD_3: 
			pushWithInst("undef","undef");
			break;
		case Opcodes.OPCODE_FMUL: 
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_FNEG:
			warningList.add(Warning.FLOAT);
			warningList.add(Warning.NEGATIVE);
			popPushInst("undef","undef", 1, 1);
			break;
		case Opcodes.OPCODE_FREM: 
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_FRETURN:
			warningList.add(Warning.FLOAT);
			oneInst("return " + pdsInfo.stackIndex(0),
				"return "+pdsInfo.stackIndex(0));
			break;
		case Opcodes.OPCODE_FSTORE: 
		case Opcodes.OPCODE_FSTORE_0: 
		case Opcodes.OPCODE_FSTORE_1: 
		case Opcodes.OPCODE_FSTORE_2: 
		case Opcodes.OPCODE_FSTORE_3:
			warningList.add(Warning.FLOAT);
			popPushInst("undef","undef", 1, 0);
			break;
		case Opcodes.OPCODE_FSUB:
			warningList.add(Warning.FLOAT);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_GETFIELD: 
			getfieldInst();
			break;
		case Opcodes.OPCODE_GETSTATIC: 
			getstaticInst();
			break;
		case Opcodes.OPCODE_GOTO: 
			oneInst(gotoStmt(false),gotoStmt(true));
			break;
		case Opcodes.OPCODE_IADD: 
			arithInst("+");
			break;
		case Opcodes.OPCODE_IALOAD: 
			ialoadInst();
			break;
		case Opcodes.OPCODE_IAND:
			warningList.add(Warning.BITWISE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_IASTORE:
			iastoreInst();
			break;
		case Opcodes.OPCODE_ICONST_0: 
		case Opcodes.OPCODE_ICONST_1: 
		case Opcodes.OPCODE_ICONST_2: 
		case Opcodes.OPCODE_ICONST_3: 
		case Opcodes.OPCODE_ICONST_4: 
		case Opcodes.OPCODE_ICONST_5: 
			pushWithInst(absInst.getOpcode() - Opcodes.OPCODE_ICONST_0);
			break;
		case Opcodes.OPCODE_ICONST_M1: 
			warningList.add(Warning.NEGATIVE);
			pushWithInst("undef","undef");
			break;
		case Opcodes.OPCODE_IDIV: 
			arithInst("/");
			break;
		case Opcodes.OPCODE_IF_ACMPEQ:
			ifIcmpInst("==");
			break;
		case Opcodes.OPCODE_IF_ACMPNE:
			ifIcmpInst("!=");
			break;
		case Opcodes.OPCODE_IF_ICMPEQ:
			ifIcmpInst("==");
			break;
		case Opcodes.OPCODE_IF_ICMPGE:
			ifIcmpInst(">=");
			break;
		case Opcodes.OPCODE_IF_ICMPGT:
			ifIcmpInst(">");
			break;
		case Opcodes.OPCODE_IF_ICMPLE:
			ifIcmpInst("<=");
			break;
		case Opcodes.OPCODE_IF_ICMPLT:
			ifIcmpInst("<");
			break;
		case Opcodes.OPCODE_IF_ICMPNE:
			ifIcmpInst("!=");
			break;
		case Opcodes.OPCODE_IFEQ: 
			ifInst("==");
			break;
		case Opcodes.OPCODE_IFGE: 
			ifInst(">=");
			break;
		case Opcodes.OPCODE_IFGT: 
			ifInst(">");
			break;
		case Opcodes.OPCODE_IFLE: 
			ifInst("<=");
			break;
		case Opcodes.OPCODE_IFLT: 
			ifInst("<");
			break;
		case Opcodes.OPCODE_IFNE: 
			ifInst("!=");
			break;
		case Opcodes.OPCODE_IFNONNULL: 
			ifInst("!=");
			break;
		case Opcodes.OPCODE_IFNULL: 
			ifInst("==");
			break;
		case Opcodes.OPCODE_IINC: 
			iincInst();
			break;
		case Opcodes.OPCODE_ILOAD: 
			pushWithInst(pdsInfo.varIndex(immediateByte()),
						pdsInfo.varIndex(immediateByte()));
			break;
		case Opcodes.OPCODE_ILOAD_0: 
		case Opcodes.OPCODE_ILOAD_1: 
		case Opcodes.OPCODE_ILOAD_2: 
		case Opcodes.OPCODE_ILOAD_3: 
			pushWithInst(pdsInfo.varIndex(absInst.getOpcode() - Opcodes.OPCODE_ILOAD_0),
						pdsInfo.varIndex(absInst.getOpcode() - Opcodes.OPCODE_ILOAD_0));
			break;
		case Opcodes.OPCODE_IMUL: 
			arithInst("*");
			break;
		case Opcodes.OPCODE_INEG:
			warningList.add(Warning.NEGATIVE);
			popPushInst("undef","undef", 1, 1);
			break;
		case Opcodes.OPCODE_INSTANCEOF: 
			instanceofInst();
			break;
		case Opcodes.OPCODE_INVOKEINTERFACE:
			invokeinterfaceInst();
			break;
		case Opcodes.OPCODE_INVOKESPECIAL: 
			invokespecialInst();
			break;
		case Opcodes.OPCODE_INVOKESTATIC:
			invokestaticInst();
			break;
		case Opcodes.OPCODE_INVOKEVIRTUAL: 
			invokevirtualInst();
			break;
		case Opcodes.OPCODE_IOR: 
			warningList.add(Warning.BITWISE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_IREM: 
			popPushInst(iremStmt(pdsInfo.stackIndex(1), pdsInfo.stackIndex(0)),
						iremStmt(pdsInfo.stackIndex(1), pdsInfo.stackIndex(0)),
						2, 1);
			break;
		case Opcodes.OPCODE_IRETURN: 
			oneInst("return " + pdsInfo.stackIndex(0),
					"return " + pdsInfo.stackIndex(0));
			break;
		case Opcodes.OPCODE_ISHL: 
			arithInst("<<");
			break;
		case Opcodes.OPCODE_ISHR:
			warningList.add(Warning.BITWISE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_ISTORE:
			popToInst(pdsInfo.varIndex(immediateByte()), pdsInfo.varIndex(immediateByte()));
			break;
		case Opcodes.OPCODE_ISTORE_0: 
		case Opcodes.OPCODE_ISTORE_1: 
		case Opcodes.OPCODE_ISTORE_2: 
		case Opcodes.OPCODE_ISTORE_3: 
			popToInst(pdsInfo.varIndex(absInst.getOpcode() - Opcodes.OPCODE_ISTORE_0),
					pdsInfo.varIndex(absInst.getOpcode() - Opcodes.OPCODE_ISTORE_0));
			break;
		case Opcodes.OPCODE_ISUB: 
			arithInst("-");
			break;
		case Opcodes.OPCODE_IUSHR:
			warningList.add(Warning.BITWISE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_IXOR:
			warningList.add(Warning.BITWISE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_JSR: 
			pushWithInst(absInst.getOffset() + 2);
			pdsStmt.addNext(gotoStmt(false),gotoStmt(true));
			break;
		case Opcodes.OPCODE_JSR_W:
			pushWithInst(absInst.getOffset() + 4);
			pdsStmt.addNext(gotoStmt(false),gotoStmt(true));
			break;
		case Opcodes.OPCODE_LADD: 
			arithInst("+");
			break;
		case Opcodes.OPCODE_LALOAD: 
			ialoadInst();
			break;
		case Opcodes.OPCODE_LAND:
			warningList.add(Warning.BITWISE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_LASTORE:
			iastoreInst();
			break;
		case Opcodes.OPCODE_LCMP:
			lcmpInst();
			break;
		case Opcodes.OPCODE_LCONST_0: 
		case Opcodes.OPCODE_LCONST_1: 
			pushWithInst(absInst.getOpcode() - Opcodes.OPCODE_LCONST_0);
			break;
		case Opcodes.OPCODE_LDC: 
			ldcInst();
			break;
		case Opcodes.OPCODE_LDC_W: 
		case Opcodes.OPCODE_LDC2_W:
			//TODO
			pushWithInst("undef","undef");
			break;
		case Opcodes.OPCODE_LDIV: 
			arithInst("/");
			break;
		case Opcodes.OPCODE_LLOAD: 
			pushWithInst(pdsInfo.varIndex(immediateByte()),
						pdsInfo.varIndex(immediateByte()));
			break;
		case Opcodes.OPCODE_LLOAD_0: 
		case Opcodes.OPCODE_LLOAD_1: 
		case Opcodes.OPCODE_LLOAD_2: 
		case Opcodes.OPCODE_LLOAD_3: 
			pushWithInst(pdsInfo.varIndex(absInst.getOpcode() - Opcodes.OPCODE_LLOAD_0),
						pdsInfo.varIndex(absInst.getOpcode() - Opcodes.OPCODE_LLOAD_0));
			break;
		case Opcodes.OPCODE_LMUL: 
			arithInst("*");
			break;
		case Opcodes.OPCODE_LNEG:
			warningList.add(Warning.NEGATIVE);
			popPushInst("undef","undef", 1, 1);
			break;
		case Opcodes.OPCODE_LOOKUPSWITCH:
			lookupswitchInst();
			break;
		case Opcodes.OPCODE_LOR: 
			warningList.add(Warning.BITWISE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_LREM: 
			popPushInst(iremStmt(pdsInfo.stackIndex(1), pdsInfo.stackIndex(0)),
						iremStmt(pdsInfo.stackIndex(1), pdsInfo.stackIndex(0)),
						2, 1);
			break;
		case Opcodes.OPCODE_LRETURN: 
			oneInst("return " + pdsInfo.stackIndex(0),
					"return " + pdsInfo.stackIndex(0));
			break;
		case Opcodes.OPCODE_LSHL: 
			arithInst("<<");
			break;
		case Opcodes.OPCODE_LSHR: 
			warningList.add(Warning.BITWISE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_LSTORE:
			popToInst(pdsInfo.varIndex(immediateByte()),
					pdsInfo.varIndex(immediateByte()));
			break;
		case Opcodes.OPCODE_LSTORE_0: 
		case Opcodes.OPCODE_LSTORE_1: 
		case Opcodes.OPCODE_LSTORE_2: 
		case Opcodes.OPCODE_LSTORE_3: 
			popToInst(pdsInfo.varIndex(absInst.getOpcode() - Opcodes.OPCODE_LSTORE_0),
					pdsInfo.varIndex(absInst.getOpcode() - Opcodes.OPCODE_LSTORE_0));
			break;
		case Opcodes.OPCODE_LSUB: 
			arithInst("-");
			break;
		case Opcodes.OPCODE_LUSHR: 
			warningList.add(Warning.BITWISE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_LXOR: 
			warningList.add(Warning.BITWISE);
			popPushInst("undef","undef", 2, 1);
			break;
		case Opcodes.OPCODE_MULTIANEWARRAY: 
			multianewarrayInst();
			break;
		case Opcodes.OPCODE_NEW: 
			newInst();
			break;
		case Opcodes.OPCODE_NEWARRAY: 
			newarrayInst();
			break;
		case Opcodes.OPCODE_NOP: 
			oneInst("skip","skip");
			break;
		case Opcodes.OPCODE_POP:
			pdsStmt.addNext(popStmt(1, 1), popStmt(1,1));
			break;
		case Opcodes.OPCODE_POP2:
			pdsStmt.addNext(popStmt(2, 2), popStmt(2,2));
			break;
		case Opcodes.OPCODE_PUTFIELD:
			putfieldInst();
			break;
		case Opcodes.OPCODE_PUTSTATIC: 
			putstaticInst();
			break;
		case Opcodes.OPCODE_RET: 
			retInst();
			break;
		case Opcodes.OPCODE_RETURN:
			pdsStmt.addNext("return", "return");
			break;
		case Opcodes.OPCODE_SALOAD: 
			ialoadInst();
			break;
		case Opcodes.OPCODE_SASTORE:
			iastoreInst();
			break;
		case Opcodes.OPCODE_SIPUSH: 
			pushWithInst(((ImmediateShortInstruction) absInst).getImmediateShort());
			break;
		case Opcodes.OPCODE_SWAP: 
			pdsStmt.addPar(stackEqual(0, 1), stackEqual(0,1));
			pdsStmt.addPar(stackEqual(1, 0), stackEqual(1,0));
			break;
		case Opcodes.OPCODE_TABLESWITCH: 
			tableswitchInst();
			break;
		//added by suncong:
		case Opcodes.OPCODE_I2B:
		case Opcodes.OPCODE_I2C:
		case Opcodes.OPCODE_I2D:
		case Opcodes.OPCODE_I2F:
		case Opcodes.OPCODE_I2L:
		case Opcodes.OPCODE_I2S:
		case Opcodes.OPCODE_D2F:
		case Opcodes.OPCODE_D2I:
		case Opcodes.OPCODE_D2L:
		case Opcodes.OPCODE_F2D:
		case Opcodes.OPCODE_F2I:
		case Opcodes.OPCODE_F2L:
		case Opcodes.OPCODE_L2D:
		case Opcodes.OPCODE_L2F:
		case Opcodes.OPCODE_L2I:
			pdsStmt.addNext("skip","skip");
		}
	}
	
	/*******************************************************************/
	/**              FUNCTIONS FOR COMMON INSTRUCTIONS                **/
	/*******************************************************************/
		
	/**
	 * Allocates array of size s0+1 in the heap. The first block stores
	 * the length of array (s0).
	 * 
	 * For HeapOption.TWODIMS: unlike newarrayInst() the second block
	 * does not store the bits of element in the heap. Every object 
	 * inside the array always has the default bit size.
	 */
	private void anewarrayInst() throws InvalidByteCodeException{
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			
			/*commented by suncong, newarrayInst() is not enough,
			need to add index to lowref, our implementation is an approximation!!!
			newarrayInst();*/
			anewarrayInstForLRecord();
			return;
		}
		
		// if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
/*annotated by suncong, do not consider twodims now
		int intBits = pdsInfo.getBits();
		String s0 = pdsInfo.stackIndex(0);
		String heapPtr = pdsInfo.getHeapPtrName();
		String newHeapPtr = heapPtr + "+" + s0	+ "+1";
		
		List<String> stmtList = new ArrayList<String>();
		stmtList.add(s0 + "=" + heapPtr);
		stmtList.addAll(storeHeap(pdsInfo.getHeapName(), s0, intBits + "*" + heapPtr, intBits));
		stmtList.add(heapPtr + "=" + newHeapPtr);
		
		if (pdsInfo.checkForHeapOverflow()) {
			
			String cond = newHeapPtr + ">" + pdsInfo.getStoredHeapSize();
			pdsStmt.addIf(ifStmt(cond, getOverflowCode()));
			pdsStmt.addIf(elseStmt(stmtList));
		} else {
			
			pdsStmt.addNext(stmtList);
		}*/
	}
	
	private void anewarrayInstForLRecord() throws InvalidByteCodeException{
		int intBits = pdsInfo.getBits();
	
		String s0 = pdsInfo.stackIndex(0);
		String heapPtr = pdsInfo.getHeapPtrName();
		String heapPtr_pair=pdsInfo.generateTLabel(heapPtr);//
		
		int pool_idx=((ImmediateShortInstruction)absInst).getImmediateShort();
		String className=pdsMethod.getClassFile().getConstantPoolEntryName(pool_idx);
		List<String> additional=new ArrayList<String>();
		if(pdsInfo.isIncludedClass(className)){
			int level=pdsInfo.getPolicy().getClassLevelByName(className);
			if(level==0){//Low.value){
				additional.add(pdsInfo.stringIndex(pdsInfo.getLowrefName(),pdsInfo.getPtrrefName())+
								"="+heapPtr+"+1");
				additional.add(pdsInfo.getPtrrefName()+"="+pdsInfo.getPtrrefName()+"+1");
			}
		}
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			String newHeapPtr = heapPtr + "+" + s0 + "+1";
			List<String> content = new ArrayList<String>();
			content.add(s0 + "=" + heapPtr);
			content.add(pdsInfo.heapIndex(heapPtr) + "=" + s0);
			content.add(heapPtr + "=" + newHeapPtr);
			if(additional.size()>0){
				content.addAll(additional);
			}
			
			String newHeapPtr_pair=heapPtr_pair+"+"+s0+"+1";
			List<String> content_pair=new ArrayList<String>();
			content_pair.add(s0+"="+heapPtr_pair);
			content_pair.add(pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),heapPtr_pair)
							 + "=" + s0);
			content_pair.add(heapPtr_pair+"="+newHeapPtr_pair);
			
			if (pdsInfo.checkForHeapOverflow()) {
				pdsStmt.addIf(ifStmt(newHeapPtr + ">" + pdsInfo.getHeapSize(), getOverflowCode(false),
									newHeapPtr_pair+">"+pdsInfo.getHeapSize(), getOverflowCode(true)));
				pdsStmt.addIf(elseStmt(content, content_pair));
			} else {				
				pdsStmt.addNext(content, content_pair);
			}
		} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
		}
	}
	
	/**
	 * Push heap[s1+s0+1] into the stack.
	 *
	 */
	private void aaloadInst() {
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			
			ialoadInst();
			return;
		}
		
		// if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
/*commented by suncong, do not consider twodims now
		String s0 = pdsInfo.stackIndex(0);
		String s1 = pdsInfo.stackIndex(1);
		int bits = pdsInfo.getBits();
		
		String length = loadHeap(pdsInfo.getHeapName(), bits + "*" + s1, bits);
		if (pdsInfo.checkForIndexOutOfBounds()) {
			pdsStmt.addIf(ifStmt(s0 + ">=" + length, getIOOBCode()));
		}
		if (pdsInfo.checkForNullPointerExceptions()) {
			pdsStmt.addIf(ifStmt(s1 + "==0", getNPECode()));
		}
		
		ArrayList<String> cond = new ArrayList<String>();
		if (pdsInfo.checkForIndexOutOfBounds()) {
			cond.add(s0 + "<" + length);
		}
		if (pdsInfo.checkForNullPointerExceptions()) {
			cond.add(s1 + "!=0");
		}
		
		String h = loadHeap(pdsInfo.getHeapName(), bits + "*("+ s1 + "+" + s0 + "+1)", bits);
		List<String> stmt = popPushStmt(h, 2, 1);
		if (cond.isEmpty()) {
			pdsStmt.addNext(stmt);
		} else {
			pdsStmt.addIf(ifStmt(cond, stmt));
		}*/
	}
	
	/**
	 * Stores s0 into heap[s2+s1+1].
	 *
	 */
	private void aastoreInst() {
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			
			iastoreInst();
			return;
		}
		
		// if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
/* commented by suncong, do not consider twodims now
		int bits = pdsInfo.getBits();
		String s0 = pdsInfo.stackIndex(0);
		String s1 = pdsInfo.stackIndex(1);
		String s2 = pdsInfo.stackIndex(2);
		
		String length = loadHeap(pdsInfo.getHeapName(), bits + "*" + s2, bits);
		if (pdsInfo.checkForIndexOutOfBounds()) {
			pdsStmt.addIf(ifStmt(s1 + ">=" + length, getIOOBCode()));
		}
		if (pdsInfo.checkForNullPointerExceptions()) {
			pdsStmt.addIf(ifStmt(s2 + "==0", getNPECode()));
		}
		
		ArrayList<String> cond = new ArrayList<String>();
		if (pdsInfo.checkForIndexOutOfBounds()) {
			cond.add(s1 + "<" + length);
		}
		if (pdsInfo.checkForNullPointerExceptions()) {
			cond.add(s2 + "!=0");
		}
		
		List<String> h = storeHeap(pdsInfo.getHeapName(), s0, bits + "*("+ s2 + "+" + s1 + "+1)", bits);
		List<String> stmt = popPushStmt(h, 3, 0);
		if (cond.isEmpty()) {
			pdsStmt.addNext(stmt);
		} else {
			pdsStmt.addIf(ifStmt(cond, stmt));
		}*/
	}
	
	private void arithInst(String op) {
		
		pdsStmt.addPar(stackArith(op), stackArith(op));
		pdsStmt.addPar(popStmt(2, 1), popStmt(2,1));
	}
	
	private void arraylengthInst() {
		
		String s0 = pdsInfo.stackIndex(0);
		String arrLength, arrLength_pair;
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE){
			arrLength = pdsInfo.heapIndex(s0);
			arrLength_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),s0);
		}
		else{	// if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
			arrLength = loadHeap(pdsInfo.getHeapName(), pdsInfo.getBits() + "*" + s0, pdsInfo.getBits());
			arrLength_pair=loadHeap(pdsInfo.generateTLabel(pdsInfo.getHeapName()), pdsInfo.getBits()+"*"+s0,
									pdsInfo.getBits());
		}
		
		if (pdsInfo.checkForNullPointerExceptions()) {
			pdsStmt.addIf(ifStmt(s0 + "==0", getNPECode(false), s0+"==0", getNPECode(true)));
			pdsStmt.addIf(elseStmt(popPushStmt(arrLength, 1, 1),popPushStmt(arrLength_pair,1,1)));
		} else {
			
			popPushInst(arrLength,arrLength_pair, 1, 1);
		}
	}
	
	private void getfieldInst() throws InvalidByteCodeException {
		
		String[] fieldName = getReferencedName(pdsMethod.getClassFile(), absInst);
		
		if (pdsInfo.isIgnoredField(fieldName)) {
			if (pdsInfo.checkForNullPointerExceptions()) {
				popPushInst("!=0","!=0", 1,1);
			} else {
				popPushInst("undef","undef", 1, 1);
			}
			return;
		}
//		System.out.println("**getField <"+fieldName[0]+","+fieldName[1]+","+fieldName[2]+"> in " +pdsMethod.getFormattedName());

		String s0 = pdsInfo.stackIndex(0);
		DefaultMutableTreeNode thisNode = pdsInfo.getClassNode(fieldName[0]);
		Enumeration e = thisNode.breadthFirstEnumeration();
		DefaultMutableTreeNode subNode;
		String[] subName;
		String formattedSubName;
		int intBits = pdsInfo.getBits();
		String objType, objType_pair;//suncong
		int fieldIndex;
		int fieldBits;
		String h, h_pair;
		List<String> cond;
		List<String> cond_pair;//suncong
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			objType = pdsInfo.heapIndex(s0);
			objType_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),s0);
		} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
			objType = loadHeap(pdsInfo.getHeapName(), intBits + "*" + s0, intBits);
			objType_pair=loadHeap(pdsInfo.generateTLabel(pdsInfo.getHeapName()), intBits+"*"+s0, intBits);
		}
		
		while (e.hasMoreElements()) {
			subNode = (DefaultMutableTreeNode) e.nextElement();
			subName = replaceClassName(fieldName, (String) subNode.getUserObject());
			formattedSubName = PDSField.formatFieldName(subName);
			fieldIndex = pdsInfo.indexOfField(formattedSubName);
			if (fieldIndex >= 0) {
				cond = new ArrayList<String>();
				cond_pair=new ArrayList<String>();
				if (pdsInfo.checkForNullPointerExceptions()) { 
					cond.add(s0 + "!=0");
					cond_pair.add(s0+"!=0");
				}
				cond.add(objType + "==" + pdsInfo.getClassIndex(subName[0]));
				cond_pair.add(objType_pair+"=="+pdsInfo.getClassIndex(subName[0]));
				
				if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
					h = pdsInfo.heapIndex(s0 + "+" + fieldIndex + "+" + 1);
					h_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),s0+"+"+fieldIndex+"+"+1);
				} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
					fieldBits = pdsInfo.getFieldBits(formattedSubName);
					h = loadHeap(pdsInfo.getHeapName(),
								intBits + "*" + s0 + "+" + intBits + "+" + fieldIndex, fieldBits);
					h_pair=loadHeap(pdsInfo.generateTLabel(pdsInfo.getHeapName()),
								intBits + "*" + s0 + "+" + intBits + "+" + fieldIndex, fieldBits);
				}
				
				pdsStmt.addIf(ifStmt(cond, popPushStmt(h, 1, 1), cond_pair, popPushStmt(h_pair,1,1)));
			}
		}
		
		if (pdsInfo.checkForNullPointerExceptions()) {
			pdsStmt.addIf(ifStmt(s0 + "==0", getNPECode(false),s0+"==0", getNPECode(true)));
		}
	}
	
	private void getstaticInst() throws InvalidByteCodeException {
		
		String[] fieldName = getReferencedName(pdsMethod.getClassFile(), absInst);
		
		if (fieldName[1].equals("$assertionsDisabled")) {
			pushWithInst("0","0");
			return;
		}
		
		if (pdsInfo.isIgnoredField(fieldName)) {
			pushWithInst("undef","undef");
			return;
		} 
		
		pushWithInst(PDSField.formatFieldName(fieldName),
				pdsInfo.generatePairLabel(PDSField.formatFieldName(fieldName), ""));
	}
	
	/**
	 * Push the value of array s1 at index s0.
	 * 
	 * For HeapOption.SIMPLE: s0 = heap[s1 + s0 + 1].
	 * 
	 * For HeapOption.TWODIMS: two local variables are added, elem and elemBit.
	 * elemBit represents how many bits each element of the array has, e.g.
	 * if the default bits are 3, then elemBit = heap[3*s1+3]<<2 
	 * + heap[3*s1+3+1]<<1 + heap[3*s1+3+2] (Note that the array length is
	 * heap[3*s1]<<2 + heap[3*s1+1] + heap[3*s1+2]). elem is the index 
	 * of the element in the heap, e.g. elem = 3*s1 + (s0*elemBit) + 2*3.
	 * The resulting Remopla statement is actually an if-statement with
	 * conditions on elemBits, e.g.
	 * if
	 *   :: elemBit == 1 -> s0 = heap[elem];
	 *   :: elemBit == 2 -> s0 = heap[elem]<<1 + heap[elem+1];
	 *   :: elemBit == 3 -> s0 = heap[elem]<<2 + heap[elem+1]<<1 + heap[elem+2];
	 * fi;
	 */
	private void ialoadInst() {
		
		String s0 = pdsInfo.stackIndex(0);
		String s1 = pdsInfo.stackIndex(1);
		String length;
		String length_pair;//suncong
		String h;
		String h_pair;//suncong
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			
			if (pdsInfo.checkForIndexOutOfBounds()) {
				length = pdsInfo.heapIndex(s1);
				length_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),s1);
				pdsStmt.addIf(ifStmt(s0 + ">=" + length, getIOOBCode(false),
									s0+">="+length_pair, getIOOBCode(true)));
			}
			if (pdsInfo.checkForNullPointerExceptions()) {
				pdsStmt.addIf(ifStmt(s1 + "==0", getNPECode(false), s1+"==0", getNPECode(true)));
			}
			
			h = pdsInfo.heapIndex(s1 + "+" + s0 + "+1");
			h_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),s1+"+"+s0+"+1");
			pdsStmt.addIf(elseStmt(popPushStmt(h, 2, 1),popPushStmt(h_pair,2,1)));
		} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
/*	commented by suncong, do not consider twodims yet.
			int bits = pdsInfo.getBits();
			String arrPtr = String.valueOf(bits)+ "*" + s1;
			String elemBit = loadHeap(pdsInfo.getHeapName(), arrPtr + "+" + String.valueOf(bits), bits);
			String elemBitVar = "elemBit";
			pdsMethod.addLocalVar(elemBitVar);
			pdsStmt.addNext(elemBitVar + "=" + elemBit);
			
			String elem = arrPtr + " + (" + s0 + "*" + elemBitVar + ")" 
					+ " + 2*" + String.valueOf(bits);
			String elemVar = "elem";
			pdsMethod.addLocalVar(elemVar, 
					PDSDefault.getMinimumBitsForHeapSize(pdsInfo.getHeapSize()));
			pdsStmt.addNext(elemVar + "=" + elem);
			
			length = loadHeap(pdsInfo.getHeapName(), arrPtr, bits);
		
			if (pdsInfo.checkForIndexOutOfBounds()) {
				pdsStmt.addIf(ifStmt(s0 + ">=" + length, getIOOBCode()));
			}
			if (pdsInfo.checkForNullPointerExceptions()) {
				pdsStmt.addIf(ifStmt(s1 + "==0", getNPECode()));
			}
			
			ArrayList<String> cond;
			for (int i = 1; i <= bits; i++) {
				
				cond = new ArrayList<String>();
				cond.add(elemBitVar + "==" + String.valueOf(i));
				if (pdsInfo.checkForIndexOutOfBounds()) {
					cond.add(s0 + "<" + length);
				}
				if (pdsInfo.checkForNullPointerExceptions()) {
					cond.add(s1 + "!=0");
				}
				h = loadHeap(pdsInfo.getHeapName(), elemVar, i);
				pdsStmt.addIf(ifStmt(cond, popPushStmt(h, 2, 1)));
			}
			
			pdsStmt.addIf(elseStmt(popPushStmt("undef", 2, 1)));*/
		}
	}

/* by suncong, for post initialization operations*/
	public void ialoadInstForPostInitOp(String arrayName){
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			String h = pdsInfo.stringIndex(arrayName, pdsInfo.stackIndex(0));
			pdsStmt.addPar(popPushStmt(h, 1, 1),null);
		} else {}
	}

/***************************************************/

	/**
	 * Stores s0 into array s2 at index s1.
	 * 
	 * For HeapOption.SIMPLE: heap[s2 + s1 + 1] = s0.
	 * 
	 * For HeapOption.TWODIMS: two local variables are added, elem and elemBit.
	 * elemBit represents how many bits each element of the array has, e.g.
	 * if the default bits are 3, then elemBit = heap[3*s2+3]<<2 
	 * + heap[3*s2+3+1]<<1 + heap[3*s2+3+2] (Note that the array length is
	 * heap[3*s2]<<2 + heap[3*s2+1] + heap[3*s2+2]). elem is the index 
	 * of the element in the heap, e.g. elem = 3*s2 + (s1*elemBit) + 2*3.
	 * The resulting Remopla statement is actually an if-statement with
	 * conditions on elemBits, e.g.
	 * if
	 *   :: elemBit == 1 -> heap[elem] = s0;
	 *   :: elemBit == 2 -> heap[elem] = s0/2, 
	 *   					heap[elem+1]=((s0<<1) - 3*(s0/2))/2;
	 *   :: elemBit == 3 -> heap[elem]=s0/4, 
	 *   					heap[elem+1]=((s0<<1) - 7*(s0/4))/4, 
	 *   					heap[elem+2]=((s0<<2) - 7*((s0<<1)/4))/4;
	 * fi;
	 */
	private void iastoreInst() {
		
		int bits = pdsInfo.getBits();
		String s0 = pdsInfo.stackIndex(0);
		String s1 = pdsInfo.stackIndex(1);
		String s2 = pdsInfo.stackIndex(2);
		String length;
		String length_pair;//suncong
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			if (pdsInfo.checkForIndexOutOfBounds()) {
				length = pdsInfo.heapIndex(s2);
				length_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),s2);
				pdsStmt.addIf(ifStmt(s1 + ">=" + length, getIOOBCode(false),
									s1+">="+length_pair, getIOOBCode(true)));
			}
			if (pdsInfo.checkForNullPointerExceptions()) {
				pdsStmt.addIf(ifStmt(s2 + "==0", getNPECode(false),s2+"==0", getNPECode(true)));
			}
			
			String h = pdsInfo.heapIndex(s2 + "+" + s1 + "+1");
			String h_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),s2+"+"+s1+"+1");
			pdsStmt.addIf(elseStmt(popPushStmt(h + "=" + s0, 3, 0),popPushStmt(h_pair+"="+s0,3,0)));
		} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
/* commented by suncong, do not consider twodims yet.		
			String arrIndex = String.valueOf(bits)+ "*" + s2;
			length = loadHeap(pdsInfo.getHeapName(), arrIndex, bits);
			String elemBit = loadHeap(pdsInfo.getHeapName(), arrIndex + "+" + String.valueOf(bits), bits);
			String elemBitVar = "elemBit";
			pdsMethod.addLocalVar(elemBitVar);
			pdsStmt.addNext(elemBitVar + "=" + elemBit);
			
			String elem = arrIndex + " + (" + s1 + "*" + elemBitVar + ")" 
					+ " + 2*" + String.valueOf(bits);
			String elemVar = "elem";
			pdsMethod.addLocalVar(elemVar, 
					PDSDefault.getMinimumBitsForHeapSize(pdsInfo.getHeapSize()));
			pdsStmt.addNext(elemVar + "=" + elem);
			
			ArrayList<String> cond;
			
			if (pdsInfo.checkForIndexOutOfBounds()) {
				pdsStmt.addIf(ifStmt(s1 + ">=" + length, getIOOBCode()));
			}
			if (pdsInfo.checkForNullPointerExceptions()) {
				pdsStmt.addIf(ifStmt(s2 + "==0", getNPECode()));
			}
			for (int i = 1; i <= bits; i++) {
				
				cond = new ArrayList<String>();
				cond.add(elemBitVar + "==" + String.valueOf(i));
				if (pdsInfo.checkForIndexOutOfBounds()) {
					cond.add(s1 + "<" + length);
				}
				if (pdsInfo.checkForNullPointerExceptions()) {
					cond.add(s2 + "!=0");
				}
				
				List<String> h = storeHeap(pdsInfo.getHeapName(), s0, elemVar, i);
				pdsStmt.addIf(ifStmt(cond, popPushStmt(h, 3, 0)));
			}
			
			pdsStmt.addIf(elseStmt(popPushStmt("undef", 3, 0)));*/
		}
	}
/*by suncong, for post initialization operations*/
	public void iastoreInstForPostInitOp(String arrayName) {
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			String h = pdsInfo.stringIndex(arrayName,pdsInfo.stackIndex(1));
			pdsStmt.addPar(popPushStmt(h + "=" + pdsInfo.stackIndex(0), 2, 0),null);
		} else { }
	}
/*by suncong, for array param preparation*/
	public void iastoreInstForArrayParam() {
		int bits = pdsInfo.getBits();
		String s0 = pdsInfo.stackIndex(0);
		String s0t=pdsInfo.generateTLabel(pdsInfo.stackIndex(0));
		String s1 = pdsInfo.stackIndex(1);
		String s1t=pdsInfo.generateTLabel(pdsInfo.stackIndex(1));
		String s2 = pdsInfo.stackIndex(2);
		String s2t=pdsInfo.generateTLabel(pdsInfo.stackIndex(2));
		String length;
		String length_pair;//suncong
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			if (pdsInfo.checkForIndexOutOfBounds()) {
				length = pdsInfo.heapIndex(s2);
				length_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),s2t);
				pdsStmt.addIf(ifStmt(s1 + ">=" + length + " || "+s1t+">="+length_pair, 
								getIOOBCode(false), "", ""));
			}
			if (pdsInfo.checkForNullPointerExceptions()) {
				pdsStmt.addIf(ifStmt(s2 + "==0"+" || "+s2t+"==0", getNPECode(false),
							"", ""));
			}
			
			String h = pdsInfo.heapIndex(s2 + "+" + s1 + "+1");
			String h_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),s2t+"+"+s1t+"+1");
			List<String> tmp=popPushStmt(h + "=" + s0, 3, 0);
			tmp.addAll(popPushStmt(h_pair+"="+s0t,3,0));
			pdsStmt.addIf(elseStmt(tmp,new ArrayList<String>()));
		} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
		}
	}
/***********************************************/
	
	private void ifIcmpInst(String op) {
		
		String s0 = pdsInfo.stackIndex(0);
		String s1 = pdsInfo.stackIndex(1);
		
		pdsStmt.addIf(ifStmt(s1 + op + s0, popPushStmt(gotoStmt(false), 2, 0),
							s1 + op + s0, popPushStmt(gotoStmt(true),2,0)));
		pdsStmt.addIf(elseStmt(popStmt(2, 2), popStmt(2, 2)));
	}
	/*by suncong, for the last instruction in the stub
	public void iflcmpInstForLabel(String op, String label){
		String s0=pdsInfo.stackIndex(0);
		String s1=pdsInfo.stackIndex(1);
		pdsStmt.addIf(ifStmt(s1+op+s0, popPushStmt(gotoStmt(label),2,0),
							s1+op+s0, popPushStmt(gotoStmt(label),2,0)));
		pdsStmt.addIf(elseStmt(popStmt(2,2),popStmt(2,2)));
	}*/
	
	private void ifInst(String op) {
		String s0 = pdsInfo.stackIndex(0);
		
		pdsStmt.addIf(ifStmt(s0 + op + "0", popPushStmt(gotoStmt(false), 1, 0),
							s0 + op + "0", popPushStmt(gotoStmt(true),1,0)));
		pdsStmt.addIf(elseStmt(popStmt(1, 1), popStmt(1, 1)));
	}
	
	private void iincInst() {
		
		IncrementInstruction incInst = (IncrementInstruction) absInst;
		int index = incInst.getImmediateByte();
		int cnst = incInst.getIncrementConst();
		
		if (cnst <= 127) {
			pdsStmt.addPar(pdsInfo.varIndex(index) + "=" 
					+ pdsInfo.varIndex(index) + "+" + String.valueOf(cnst),
					pdsInfo.varIndex(index) + "=" 
					+ pdsInfo.varIndex(index) + "+" + String.valueOf(cnst));
		} else {
			pdsStmt.addPar(pdsInfo.varIndex(index) + "=" 
					+ pdsInfo.varIndex(index) + "-" + String.valueOf(256 - cnst),
					pdsInfo.varIndex(index) + "=" 
					+ pdsInfo.varIndex(index) + "-" + String.valueOf(256 - cnst)
					);
		}
	}
	
	private void invokeinterfaceInst() throws InvalidByteCodeException {
		
		String[] calledName = calleeInterfaceName();
		int paramCount = PDSMethod.countParam(calledName[2]) + 1;
		int retCount = PDSMethod.isVoid(calledName[2]) ? 0 : 1;
		Collection<String> impList = pdsInfo.getImplementor(calledName[0]);
		
		for (String impName : impList) {
			String[] names = replaceClassName(calledName, impName);
			invokevirtualInst(pdsMethod.getClassFile(), names, paramCount, retCount);
		}
		
		if (pdsStmt.isEmpty()) {
			oneInst("skip","skip");
			logger.debug("No methods found for interface call "	+ Arrays.toString(calledName));
		}
	}
	
	private void invokespecialInst() throws InvalidByteCodeException {
		
		logger.debug("invokespeical instruction");
		String[] calledName = getReferencedName(pdsMethod.getClassFile(), absInst);
		int paramCount = PDSMethod.countParam(calledName[2]) + 1;
		int retCount = PDSMethod.isVoid(calledName[2]) ? 0 : 1;
		
		if (calledName[0].equals("java/lang/AssertionError") && calledName[1].equals("<init>")) {
			oneInst(gotoStmt(pdsInfo.getLabelAssertError()), gotoStmt(pdsInfo.getLabelAssertError()));
			return;
		}
		
		if (PDSString.isInvokespecialStringBuilder(calledName)) {
			
			pdsStmt = PDSString.invokespecialStringBuilder(pdsInfo, pdsMethod, this, calledName);
			if (!pdsStmt.isEmpty()) return;
		}
		
		if (!pdsInfo.isIncludedMethod(calledName)) {
			logger.debug("\tnot included method, paramCount=" + paramCount + ", retCount=" + retCount);
			if (pdsInfo.checkForNullPointerExceptions()) {
				popPushInst("!=0","!=0", paramCount, retCount);
			} else {
				popPushInst("undef","undef", paramCount, retCount);
			}
			return;
		}
		
		String calledMethodName = PDSMethod.formatMethodName(calledName);
		String calledMethodName_pair=pdsInfo.generatePairLabel(calledMethodName,"");//
		String param = paramList(paramCount);
		if (pdsInfo.checkForNullPointerExceptions()) {
			pdsStmt.addIf(ifStmt(pdsInfo.stackIndex(paramCount - 1) + "==0", getNPECode(false),
								pdsInfo.stackIndex(paramCount - 1) + "==0", getNPECode(true)));
			pdsStmt.addIf(elseStmt(popPushStmt(calledMethodName + param, paramCount, retCount),
								popPushStmt(calledMethodName_pair + param, paramCount, retCount)));
		} else {
			popPushInst(calledMethodName + param, calledMethodName_pair + param, paramCount, retCount);
		}
	}
	
	private void invokestaticInst() throws InvalidByteCodeException {
		
		String[] calledName = getReferencedName(pdsMethod.getClassFile(), absInst);
		int paramCount = PDSMethod.countParam(calledName[2]);
		int retCount = PDSMethod.isVoid(calledName[2]) ? 0 : 1;
		
		if (!pdsInfo.isIncludedMethod(calledName)) {
			if (pdsInfo.checkForNullPointerExceptions()) {
				popPushInst("!=0","!=0", paramCount, retCount);
			} else {
				popPushInst("undef","undef", paramCount, retCount);
			}
			return;
		}
		
		String calledMethodName = PDSMethod.formatMethodName(calledName);
		String calledMethodName_pair=pdsInfo.generatePairLabel(calledMethodName,"");//
		String param = paramList(paramCount);
		
		popPushInst(calledMethodName + param, calledMethodName_pair+param, paramCount, retCount);
	}
	
	private void invokevirtualInst() throws InvalidByteCodeException {
		
		String[] calledName = getReferencedName(pdsMethod.getClassFile(), absInst);
		
		if (PDSString.isInvokevirtualString(calledName)) {
			
			pdsStmt = PDSString.invokevirtualString(pdsInfo, pdsMethod, this, calledName);
			if (!pdsStmt.isEmpty()) return;
		}
		
		int paramCount = PDSMethod.countParam(calledName[2]) + 1;
		int retCount = PDSMethod.isVoid(calledName[2]) ? 0 : 1;
		invokevirtualInst(pdsMethod.getClassFile(), calledName, paramCount, retCount);
		
		if (pdsStmt.isEmpty()) {
			pdsStmt.addNext("skip","skip");
			logger.debug("No methods found for virtual call " + Arrays.toString(calledName));
		}
	}
	
	private void invokevirtualInst(ClassFile cf, String[] calledName,
			int paramCount, int retCount) throws InvalidByteCodeException {
		
		String heapPtr = pdsInfo.stackIndex(paramCount - 1);
		String objType, objType_pair;
		String param = paramList(paramCount);
		ClassNode callNode = pdsInfo.getClassNode(calledName[0]);
		int intBits = pdsInfo.getBits();
		List<String> stmt;
		List<String> stmt_pair;
		String cond, cond_pair;
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			objType = pdsInfo.heapIndex(heapPtr);
			objType_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),heapPtr);
		} else {
			objType = loadHeap(pdsInfo.getHeapName(), intBits + "*" + heapPtr, intBits);
			objType_pair=loadHeap(pdsInfo.generateTLabel(pdsInfo.getHeapName()), intBits + "*" + heapPtr, intBits);
		}
		
		if (pdsInfo.isIgnoredMethod(calledName) || callNode == null) {			
			if (pdsInfo.checkForNullPointerExceptions() && PDSMethod.returnsReference(calledName[2])) {
				pdsStmt.addIf(ifStmt(heapPtr + "==0", getNPECode(false),
									heapPtr + "==0", getNPECode(true)));
				stmt = popPushStmt("!=0", paramCount, retCount);
				if (pdsInfo.isIgnoredClass(calledName[0]) || callNode == null) {
					pdsStmt.addIf(elseStmt(stmt, stmt));
				} else {					
					cond = objType + "==" + pdsInfo.getClassIndex(calledName[0]);
					cond_pair=objType_pair+"=="+pdsInfo.getClassIndex(calledName[0]);
					pdsStmt.addIf(ifStmt(cond, stmt, cond_pair, stmt));
				}
			} 
			else if (retCount > 0) {
				
				stmt = popPushStmt("undef", paramCount, retCount);
				if (pdsInfo.isIgnoredClass(calledName[0]) || callNode == null) {
					pdsStmt.addNext(stmt, stmt);
				}
				else {
					cond = objType + "==" + pdsInfo.getClassIndex(calledName[0]);
					cond_pair=objType_pair+"=="+pdsInfo.getClassIndex(calledName[0]);
					pdsStmt.addIf(ifStmt(cond, stmt, cond_pair, stmt));
				}
			}
			return;
		}
		
		// objects this method is called upon must extend the callNode, so
		// determine for each class that extends callNode the most specialized
		// method
		
		Enumeration children = callNode.breadthFirstEnumeration();

		while (children.hasMoreElements()) {
			ClassNode classNode = (ClassNode)children.nextElement();
			String className = classNode.getClassName();

			// if class is abstract, ignore it
			ClassFile classFile = pdsInfo.getClassFile(className);
			if ((classFile.getAccessFlags() & AccessFlags.ACC_ABSTRACT) != 0) {
				continue;
			}
			
			// go upwards to find most specialized method
			while (classNode != null) {
				String[] methodCall = replaceClassName(calledName, classNode.getClassName());
				if (pdsInfo.isIncludedMethod(methodCall)) {
					String calledMethodName = PDSMethod.formatMethodName(methodCall);
					String calledMethodName_pair=pdsInfo.generatePairLabel(calledMethodName,"");
					cond = objType + "==" + pdsInfo.getClassIndex(className);
					cond_pair=objType_pair+"=="+pdsInfo.getClassIndex(className);
					stmt = popPushStmt(calledMethodName + param, paramCount, retCount);
					stmt_pair=popPushStmt(calledMethodName_pair+param,paramCount,retCount);
					pdsStmt.addIf(ifStmt(cond, stmt, cond_pair, stmt_pair));
					break;
				}
				classNode = (ClassNode)classNode.getParent();
			}
		}
		
		return;
	}
	
	private void instanceofInst() throws InvalidByteCodeException {

		ImmediateShortInstruction instruction = (ImmediateShortInstruction) absInst;
		ConstantClassInfo info = (ConstantClassInfo) 
			pdsMethod.getClassFile().getConstantPoolEntry(instruction.getImmediateShort(), ConstantClassInfo.class);

		String typeName = info.getName();
		String objType  = pdsInfo.heapIndex(pdsInfo.stackIndex(0));
		String objType_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),pdsInfo.stackIndex(0));
		
		ClassNode classNode = pdsInfo.getClassNode(typeName);
		
		if (classNode != null) {
			Enumeration children = classNode.breadthFirstEnumeration();
			if (children.hasMoreElements()) {
				while (children.hasMoreElements()) {
					classNode = (ClassNode) children.nextElement();
					int classIndex = pdsInfo.getClassIndex(classNode.getClassName());
					pdsStmt.addIf(ifStmt(objType + "==" + classIndex, popPushStmt("1", 1, 1),
										objType_pair+"=="+classIndex, popPushStmt("1",1,1)));
				}
				pdsStmt.addIf(elseStmt(popPushStmt("0", 1, 1), popPushStmt("0",1,1)));
			}
		}
		else {
			Collection<String> implementers = pdsInfo.getImplementor(typeName);
			if (!implementers.isEmpty()) {
				for (String className : implementers) {
					int classIndex = pdsInfo.getClassIndex(className);
					pdsStmt.addIf(ifStmt(objType + "==" + classIndex, popPushStmt("1", 1, 1),
										objType_pair+"=="+classIndex, popPushStmt("1",1,1)));
				}
				pdsStmt.addIf(elseStmt(popPushStmt("0", 1, 1),
										popPushStmt("0",1,1)));
			}
			else {
				popPushInst("0","0", 1, 1);
			}
		}
	}
	
	private void lcmpInst() {
		
		String s0 = pdsInfo.stackIndex(0);
		String s1 = pdsInfo.stackIndex(1);
		
		pdsStmt.addIf(ifStmt(s1 + ">" + s0, popPushStmt("1", 2, 1),
							s1 + ">" + s0, popPushStmt("1", 2, 1)));
		pdsStmt.addIf(ifStmt(s1 + "==" + s0, popPushStmt("0", 2, 1),
							s1 + "==" + s0, popPushStmt("0", 2, 1)));
		pdsStmt.addIf(elseStmt(popPushStmt("undef", 2, 1),
								popPushStmt("undef",2,1)));
	}
	
	private void ldcInst() throws InvalidByteCodeException {
		
		ClassFile cf = pdsMethod.getClassFile();
		CPInfo[] cpInfo = cf.getConstantPool();
		int immByte = immediateByte();
		int cpTag = cpInfo[immByte].getTag();
		
		if (cpTag == CPInfo.CONSTANT_INTEGER) {
			ConstantIntegerInfo ciInfo = (ConstantIntegerInfo) cpInfo[immByte];
			pushWithInst(ciInfo.getInt());
			return;
		} else if (cpTag == CPInfo.CONSTANT_STRING) {
			pdsStmt =  PDSString.ldcString(cpInfo, immByte, pdsInfo, this);
			return;
		} else { // if (cpTag == CPInfo.CONSTANT_FLOAT)			
			warningList.add(Warning.FLOAT);
			pushWithInst("undef","undef");
		}
	}
	
	private void lookupswitchInst() {
		
		LookupSwitchInstruction lsInst = (LookupSwitchInstruction) absInst;
		List moPairs = lsInst.getMatchOffsetPairs();
		int offset = lsInst.getOffset();
		int match;
		int target;
		String methodName = pdsMethod.getFormattedName();
		String methodName_pair=pdsInfo.generatePairLabel(methodName,"");
		
		for (int i =  0; i < moPairs.size(); i++) {			
			match = ((MatchOffsetPair) moPairs.get(i)).getMatch();
			target = offset + ((MatchOffsetPair) moPairs.get(i)).getOffset();
			pdsStmt.addIf(ifStmt(pdsInfo.stackIndex(0) + "==" + match, popPushStmt(gotoStmt(methodName + target), 1, 0),
								pdsInfo.stackIndex(0)+"=="+match, popPushStmt(gotoStmt(methodName_pair+target),1,0)));
		}
		target = offset + lsInst.getDefaultOffset();
		pdsStmt.addIf(elseStmt(popPushStmt(gotoStmt(methodName + target), 1, 0),
							popPushStmt(gotoStmt(methodName_pair+target),1,0)));
	}
	
	/**
	 * @throws InvalidByteCodeException if there are problems interpreting the 
	 * bytecode or if the instruction creates an array with more than 4 dimensions,
	 * which is not handled yet.
	 */
	private void multianewarrayInst() throws InvalidByteCodeException {
		
		int dim = ((MultianewarrayInstruction) absInst).getDimensions();
		
		if (dim > PDSMultiArrayInitializerMethod.MAX_DIMENSIONS) {
			throw new InvalidByteCodeException("Multidmensional arrays with more than "
					+ PDSMultiArrayInitializerMethod.MAX_DIMENSIONS 
					+ "  dimensions are not supported.");
		}
		
		String heapPtr = pdsInfo.getHeapPtrName();
		String heapPtr_pair=pdsInfo.generateTLabel(pdsInfo.getHeapPtrName());//
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			
			String newHeapPtr = heapPtr + "+" + createMultiArraySizeExpression(dim);
			String newHeapPtr_pair = heapPtr_pair + "+" + createMultiArraySizeExpression(dim);
			String heapUpdate = heapPtr + "=" + newHeapPtr;
			String heapUpdate_pair = heapPtr_pair + "=" + newHeapPtr_pair;
	
			// add heap initialization code here
			StringBuilder content = new StringBuilder();
			content.append(createMultiArrayInitializerCall(dim));
			content.append(";\n\t   ");
			List<String> push = popPushStmt(heapPtr, 0, 1);
			push.add(heapUpdate);
			content.append(PDSStmt.commaList(push));
			//by suncong:
			StringBuilder content_pair=new StringBuilder();
			content_pair.append(createMultiArrayInitializerCall(dim));
			content_pair.append(";\n\t   ");
			List<String> push_pair=popPushStmt(heapPtr_pair,0,1);
			push_pair.add(heapUpdate_pair);
			content_pair.append(pdsStmt.commaList(push_pair));
		
			if (pdsInfo.checkForHeapOverflow()) {
				pdsStmt.addIf(ifStmt(newHeapPtr + ">" + pdsInfo.getStoredHeapSize(), getOverflowCode(false),
									newHeapPtr_pair+">"+pdsInfo.getStoredHeapSize(), getOverflowCode(true)));
				pdsStmt.addIf(elseStmt(content.toString(), content_pair.toString()));
			} 
			else {
				pdsStmt.addPar(content.toString(), content_pair.toString());
			}
		} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
/* commented by suncong, do not consider twodims yet.
			// TODO Clean me!
			int intBits = pdsInfo.getBits();
			String s0 = pdsInfo.stackIndex(0);
			int arrBits = pdsMethod.getBitsAtPc(absInst.getOffset());
			String s0TimesArrBits = "(" + s0 + "*" + arrBits + ")";
			String arrLength1 = s0TimesArrBits + "/" + intBits + "+2";
			String arrLength2 = arrLength1 + "+1";
			String s0ModIntBits = iremStmt(s0TimesArrBits, String.valueOf(intBits));
			String cond1 = s0ModIntBits + "==0";
			String cond2 = s0ModIntBits + "!=0";
			
			String arrLengthVar = "arrLength";
			pdsMethod.addLocalVar(arrLengthVar);
			pdsStmt.addIf(ifStmt(cond1, arrLengthVar + "=" + arrLength1));
			pdsStmt.addIf(ifStmt(cond2, arrLengthVar + "=" + arrLength2));
			
			String counterVar = "counter";
			pdsMethod.addLocalVar(counterVar);
			String counterVar2 = "counter2";
			pdsMethod.addLocalVar(counterVar2);
			String indexVar = "index";
			pdsMethod.addLocalVar(indexVar);
			String lastPtrVar = "lastPtr";
			pdsMethod.addLocalVar(lastPtrVar);
			
			pdsStmt.addNext(counterVar + "=0");
			pdsStmt.addPar(lastPtrVar + "=" + heapPtr);
			
			StringBuilder cont = new StringBuilder();
			cont.append("do\n");
			cont.append("\t:: ");
			cont.append(counterVar);
			cont.append("<");
			StringBuilder s = new StringBuilder();
			for (int i = dim-1; i>0; i--) {
				s.append(pdsInfo.stackIndex(i));
				if (i > 1) s.append("*");
			}
			cont.append(s);
			cont.append(" -> ");
			cont.append(PDSStmt.commaList(storeHeap(pdsInfo.getHeapName(), s0, 
					intBits + "*" + heapPtr, intBits)));
			cont.append(", ");
			cont.append(PDSStmt.commaList(storeHeap(pdsInfo.getHeapName(), arrBits, 
					intBits + "*" + heapPtr + "+" + intBits, intBits)));
			cont.append(", ");
			cont.append(heapPtr + "=" + heapPtr + "+" + arrLengthVar);
			cont.append(", ");
			cont.append(counterVar + "=" + counterVar + "+1");
			cont.append(";\n");
			cont.append("\t:: else -> break;\n");
			cont.append("od");
			pdsStmt.addNext(cont.toString());
			
			for (int i = 1; i < dim; i++) {
				
				String si = pdsInfo.stackIndex(i);
				s = new StringBuilder();
				for (int j = dim-1; j>i; j--) {
					s.append(pdsInfo.stackIndex(j));
					if (j > i + 1) s.append("*");
				}
				
				cont = new StringBuilder();
				cont.append(counterVar + "=0");
				cont.append(", ");
				cont.append(indexVar + "=" + lastPtrVar);
				cont.append(", ");
				cont.append(lastPtrVar + "=" + heapPtr);
				cont.append(";\n");
				cont.append("do\n");
				cont.append("\t:: ");
				cont.append(counterVar);
				cont.append("<");
				if (i < dim - 1) cont.append(s);
				else cont.append("1");
				cont.append(" -> ");
				cont.append(PDSStmt.commaList(storeHeap(pdsInfo.getHeapName(), si, 
						intBits + "*" + heapPtr, intBits)));
				cont.append(", ");
				cont.append(counterVar2 + "=0;\n");
				cont.append("\tdo\n");
				cont.append("\t\t::");
				cont.append(counterVar2 + "<" + si);
				cont.append(" -> ");
				cont.append(PDSStmt.commaList(storeHeap(pdsInfo.getHeapName(), indexVar, 
						intBits + "*("+ heapPtr + "+" + counterVar2 + "+1)",
						intBits)));
				cont.append(", ");
				cont.append(indexVar + "=" + indexVar + "+" + arrLengthVar);
				cont.append(", ");
				cont.append(counterVar2 + "=" + counterVar2 + "+1;\n");
				cont.append("\t\t:: else -> break;\n");
				cont.append("\tod;\n");
				cont.append(heapPtr + "=" + heapPtr + "+" + si + "+1");
				cont.append(", ");
				cont.append(counterVar + "=" + counterVar + "+1");
				cont.append(";\n");
				cont.append("\t:: else -> break;\n");
				cont.append("od");
				pdsStmt.addNext(cont.toString());
				
				if (i < dim -1)
					pdsStmt.addNext(arrLengthVar + "=" + si + "+1");
			}
			
			pdsStmt.addNext(popPushStmt(lastPtrVar, dim, 1));*/
		}
	}
	
	private String createMultiArraySizeExpression(int dim)
	{
		StringBuilder size = new StringBuilder();
		
		for (int i = dim - 1; i >= 0; i--) {
			for (int j = dim - 1; j > i; j--) {
				size.append(pdsInfo.stackIndex(j));
				size.append(" * ");
			}
			size.append("(").append(pdsInfo.stackIndex(i)).append(" + 1)");
			if (i > 0) {
				size.append(" + ");
			}
		}
		return size.toString();
	}
	
	private String createMultiArrayInitializerCall(int dim)
	{
		StringBuilder code = new StringBuilder(PDSMultiArrayInitializerMethod.NAME);
		code.append("(").append(pdsInfo.getHeapPtrName()).append(", ");
		for (int i = dim - 1; i >= 0; i--) {
			code.append(pdsInfo.stackIndex(i));
			if (i > 0) {
				code.append(", ");
			}
		}
		final int maxDim = PDSMultiArrayInitializerMethod.MAX_DIMENSIONS;
		if (dim < maxDim) {
			code.append(", ");
			for (int i = maxDim - dim - 1; i >= 0;  i--) {
				code.append("0");
				if (i > 0) {
					code.append(", ");
				}
			}
		}
		code.append(")");
		return code.toString();
	}
	
	private void newInst() throws InvalidByteCodeException {
		
		String className = getNewedClassName(pdsMethod.getClassFile(), absInst);
		/************************unrelated***********************************/
		if (className.equals("java/lang/StringBuilder")) {
			
			int sbSize = pdsInfo.getStringBuilderSize();
			String heapPtr = pdsInfo.getHeapPtrName();
			String heapPtr_pair=pdsInfo.generateTLabel(heapPtr);//
			String s0 = pdsInfo.stackIndex(0);
			
			if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
				
				String newHeapPtr = heapPtr + "+" + sbSize + "+1";
				List<String> content = new ArrayList<String>();
				content.add(s0 + "=" + heapPtr);
				content.add(pdsInfo.heapIndex(heapPtr) + "=0");
				content.add(heapPtr + "=" + newHeapPtr);
				
				String newHeapPtr_pair=heapPtr_pair+"+"+sbSize+"+1";
				List<String> content_pair=new ArrayList<String>();
				content_pair.add(s0+"="+heapPtr_pair);
				content_pair.add(pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),heapPtr_pair) + "=0");
				content_pair.add(heapPtr_pair+"="+newHeapPtr_pair);
				
				if (pdsInfo.checkForHeapOverflow()) {
					pdsStmt.addIf(ifStmt(newHeapPtr + ">" + pdsInfo.getHeapSize(),getOverflowCode(false),
										newHeapPtr_pair+">"+pdsInfo.getHeapSize(),getOverflowCode(true)));
					pdsStmt.addIf(elseStmt(content, content_pair));
				} else {
					pdsStmt.addNext(content, content_pair);
				}
			} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
/*
 *				int intBits = pdsInfo.getBits();
				int charBits = pdsInfo.getCharBits();
				int blocks = countBlocks(sbSize * charBits, intBits);
				String newHeapPtr = heapPtr + "+" + blocks + "+1";
				
				List<String> stmtList = new ArrayList<String>();
				stmtList.add(s0 + "=" + heapPtr);
				stmtList.addAll(storeHeap(pdsInfo.getHeapName(), 0, intBits + "*" + heapPtr, intBits));
				stmtList.add(heapPtr + "=" + newHeapPtr);
				
				if (pdsInfo.checkForHeapOverflow()) {
					
					String cond = newHeapPtr + ">" + pdsInfo.getStoredHeapSize();
					pdsStmt.addIf(ifStmt(cond, getOverflowCode()));
					pdsStmt.addIf(elseStmt(stmtList));
				} else {
					
					pdsStmt.addNext(stmtList);
				}*/
			}
			return;
		}
		/*******************************************************************/
		if (pdsInfo.isIncludedClass(className)) {
			
			String heapPtr = pdsInfo.getHeapPtrName();
			String heapPtr_p=pdsInfo.generateTLabel(heapPtr);//
			
			int classSize = pdsInfo.getClassSize(className);
			
			//String newHeapPtr = heapPtr + "+" + classSize + "+1";
			String heapUpdate = heapPtr+"="+heapPtr+"+"+classSize+"+1";//ptr=ptr+k+1
			//String newHeapPtr_pair=heapPtr_pair+"+"+classSize+"+1";//
			String heapUpdate_p=heapPtr_p+"="+heapPtr_p+"+"+classSize+"+1";//ptrt=ptrt+k+1
			
			int classIndex = pdsInfo.getClassIndex(className);
			
			List<String> content = popPushStmt(heapPtr,0,1);
			List<String> content_p=popPushStmt(heapPtr_p,0,1);//
			if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
				content.add(pdsInfo.heapIndex(heapPtr) + "=" + classIndex);
				content_p.add(pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),
													heapPtr_p) + "=" + classIndex);
			} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
/*commented by suncong, do not consider twodims yet.
				int intBits = pdsInfo.getBits();
				content.addAll(storeHeap(pdsInfo.getHeapName(), classIndex, 
						intBits + "*" + heapPtr, intBits));*/
			}
			content.add(heapUpdate);
			content_p.add(heapUpdate_p);
			
			//content.addAll(content_p);
			//content_p.clear();
			
			List<FieldStruct> flds=pdsInfo.getPolicyFields(classIndex);
			int lowidx_cnt=0;
			int lowref_cnt=0;
			for(FieldStruct fs: flds){
				if(fs.low()){//low field
					if(fs.primitive()){
						if(!fs.bArray()){
							String cur_lowidx=lowidx_cnt>0?pdsInfo.getPtridxName()+"+"+
											String.valueOf(lowidx_cnt):pdsInfo.getPtridxName();
							String lowidx=pdsInfo.stringIndex(pdsInfo.getLowidx1Name(),cur_lowidx)
										+"="+pdsInfo.getHeapPtrName()+"+"+fs.getOffset()+"+1";
							content.add(lowidx);
							lowidx=pdsInfo.stringIndex(pdsInfo.getLowidx2Name(),cur_lowidx)
										+"="+pdsInfo.getHeapPtrName();
							content.add(lowidx);
							lowidx_cnt++;
						}
						else{//primitive array
							/*fix me*/
						}
					}
					else{//reference type
						if(!fs.bArray()){
							String cur_lowref=lowref_cnt>0?pdsInfo.getPtrrefName()+"+"+
											String.valueOf(lowref_cnt):pdsInfo.getPtrrefName();
							String lowref=pdsInfo.stringIndex(pdsInfo.getLowrefName(),cur_lowref)
										+"="+pdsInfo.getHeapPtrName()+"+"+fs.getOffset()+"+1";
							content.add(lowref);
							lowref_cnt++;
						}
						else{
							/*not support yet*/
						}
					}
				}
			}
			if(lowidx_cnt>0){
				String newIdxPtr=pdsInfo.getPtridxName()+"="+pdsInfo.getPtridxName()+"+"+String.valueOf(lowidx_cnt);
				content.add(newIdxPtr);
				//setNewedLowCount(ptridx_offset);//added the count of low indices newed by this instruction
			}
			if(lowref_cnt>0){
				String newRefPtr=pdsInfo.getPtrrefName()+"="+pdsInfo.getPtrrefName()+"+"+String.valueOf(lowref_cnt);
				content.add(newRefPtr);
			}
			
			if (pdsInfo.checkForHeapOverflow()) {
				pdsStmt.addIf(ifStmt(heapPtr+"+"+classSize+"+1>"+pdsInfo.getStoredHeapSize(),
									getOverflowCode(false),
									heapPtr_p+"+"+classSize+"+1>"+pdsInfo.getStoredHeapSize(),
									getOverflowCode(true)));
				pdsStmt.addIf(elseStmt(content, content_p));
			} else {
				pdsStmt.addNext(content, content_p);
			}
		} else {
			pushWithInst("undef","undef");
		}
	}
	public void newInstForInitWrapper() throws InvalidByteCodeException{
		String className = getNewedClassName(pdsMethod.getClassFile(), absInst);
		if (pdsInfo.isIncludedClass(className)) {
			String heapPtr = pdsInfo.getHeapPtrName();
			String heapPtr_p=pdsInfo.generateTLabel(heapPtr);//
			
			int classSize = pdsInfo.getClassSize(className);
			
			String heapUpdate = heapPtr+"="+heapPtr+"+"+classSize+"+1";//ptr=ptr+k+1
			String heapUpdate_p=heapPtr_p+"="+heapPtr_p+"+"+classSize+"+1";//ptrt=ptrt+k+1
			
			int classIndex = pdsInfo.getClassIndex(className);
			
			List<String> content = popPushStmt(heapPtr,0,1);
			List<String> content_p=popPushStmt2(heapPtr_p,0,1);//
			if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
				content.add(pdsInfo.heapIndex(heapPtr) + "=" + classIndex);
				content_p.add(pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),
													heapPtr_p) + "=" + classIndex);
			} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
			}
			content.add(heapUpdate);
			content_p.add(heapUpdate_p);
			
			content.addAll(content_p);
			content_p.clear();
			
			ArrayList<FieldStruct> flds=pdsInfo.getPolicyFields(classIndex);
			int lowidx_cnt=0;
			int lowref_cnt=0;
			for(FieldStruct fs: flds){
				if(fs.low()){//low field
					if(fs.primitive()){
						if(!fs.bArray()){
							String lowidx=pdsInfo.stringIndex(pdsInfo.getLowidx1Name(),pdsInfo.getPtridxName())
										+"="+pdsInfo.getHeapPtrName()+"+"+fs.getOffset()+"+1";
							content.add(lowidx);
							lowidx=pdsInfo.stringIndex(pdsInfo.getLowidx2Name(),pdsInfo.getPtridxName())
										+"="+pdsInfo.getHeapPtrName();
							content.add(lowidx);
							lowidx_cnt++;
						}
						else{//primitive array
							/*fix me*/
						}
					}
					else{//reference type
						if(!fs.bArray()){
							String lowref=pdsInfo.stringIndex(pdsInfo.getLowrefName(),pdsInfo.getPtrrefName())
										+"="+pdsInfo.getHeapPtrName()+"+"+fs.getOffset()+"+1";
							content.add(lowref);
							lowref_cnt++;
						}
						else{
							/*not support yet*/
						}
					}
				}
			}
			if(lowidx_cnt>0){
				String newIdxPtr=pdsInfo.getPtridxName()+"="+pdsInfo.getPtridxName()+"+"+String.valueOf(lowidx_cnt);
				content.add(newIdxPtr);
			}
			if(lowref_cnt>0){
				String newRefPtr=pdsInfo.getPtrrefName()+"="+pdsInfo.getPtrrefName()+"+"+String.valueOf(lowref_cnt);
				content.add(newRefPtr);
			}
			
			if (pdsInfo.checkForHeapOverflow()) {
				pdsStmt.addIf(ifStmt(heapPtr+"+"+classSize+"+1>"+pdsInfo.getStoredHeapSize()+" || "+
							heapPtr_p+"+"+classSize+"+1>"+pdsInfo.getStoredHeapSize(),getOverflowCode(false),
							"", ""));
				pdsStmt.addIf(elseStmt(content, content_p));
			} else {
				pdsStmt.addNext(content, content_p);
			}
		} else {
			pushWithInst("undef","undef");
		}
	}
/*	public void newInstForInitWrapper() throws InvalidByteCodeException{
		String className = getNewedClassName(pdsMethod.getClassFile(), absInst);
		
		if (pdsInfo.isIncludedClass(className)) {
			
			String heapPtr = pdsInfo.getHeapPtrName();
			String heapPtr_pair=pdsInfo.generateTLabel(heapPtr);//
			
			int classSize = pdsInfo.getClassSize(className);
			
			String newHeapPtr = heapPtr + "+" + classSize + "+1";//ptr+1+1
			String heapUpdate = heapPtr + "=" + newHeapPtr;//ptr=ptr+1+1
			String newHeapPtr_pair=heapPtr_pair+"+"+classSize+"+1";//ptrt+1+1
			String heapUpdate_pair=heapPtr_pair+"="+newHeapPtr_pair;//ptrt=ptrt+1+1
			
			int classIndex = pdsInfo.getClassIndex(className);
			
			List<String> content = popPushStmt(heapPtr, 0, 1);//s0=ptr...
			List<String> content_pair=popPushStmt2(heapPtr_pair,0,1);//s0t=ptrt...
			if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
				content.add(pdsInfo.heapIndex(heapPtr) + "=" + classIndex);//heap[ptr]=1
				content_pair.add(pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),
													heapPtr_pair) + "=" + classIndex);//heapt[ptrt]=1
			} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
			}
			content.add(heapUpdate);
			content_pair.add(heapUpdate_pair);

			content.addAll(content_pair);
			content_pair.clear();
			
			ArrayList<FieldStruct> flds=pdsInfo.getPolicyFields(classIndex);
			int ptridx_offset=0;
			for(FieldStruct fs: flds){
				if(fs.primitive() && fs.low()){
					if(!fs.bArray()){
						String lowidx=pdsInfo.stringIndex(pdsInfo.getLowidxName(),pdsInfo.getPtridxName())
							+ "=" + pdsInfo.getHeapPtrName() + "+" + fs.getOffset() + "+1";
						content.add(lowidx);
						ptridx_offset++;
					}
					else{//primitive array, to finish
						
					}
				}
			}
			if(ptridx_offset>0){
				String newIdxPtr=pdsInfo.getPtridxName() + "=" + pdsInfo.getPtridxName()
									+ "+" + String.valueOf(ptridx_offset);
				content.add(newIdxPtr);
				setNewedLowCount(ptridx_offset);//added the count of low indices newed by this instruction
			}
			
			if (pdsInfo.checkForHeapOverflow()) {
				pdsStmt.addIf(ifStmt(newHeapPtr + ">" + pdsInfo.getStoredHeapSize() + " || " +
								newHeapPtr_pair+">"+pdsInfo.getStoredHeapSize(),getOverflowCode(false),
								"", ""));
				pdsStmt.addIf(elseStmt(content, content_pair));
			} else {
				pdsStmt.addNext(content, content_pair);
			}
		} else {
			pushWithInst("undef","undef");
		}
	}*/

	/**
	 * For HeapOption.SIMPLE: Allocates (s0 + 1) blocks of memory in the heap.
	 * The first block stores the length of array.
	 * 
	 * For HeapOption.TWODIMS: Allocates (ceil((s0*arrBits)/intBits) + 2) 
	 * blocks of memory in the heap. The first block stores the length of array,
	 * whereas the second block tells how many bits each element of the array
	 * has. We simulate ceil function by using if-statement by the following
	 * way:
	 * <pre>
	 * if
	 *   :: (s0*arrBits)%intBits == 0 -> allocate (s0*arrBits)/intBits + 2
	 *   :: (s0*arrBits)%intBits != 0 -> allocate (s0*arrBits)/intBits + 3
	 * fi;
	 * </pre>
	 */
	private void newarrayInst() {
		int intBits = pdsInfo.getBits();
		String s0 = pdsInfo.stackIndex(0);
		String heapPtr = pdsInfo.getHeapPtrName();
		String heapPtr_pair=pdsInfo.generateTLabel(heapPtr);//
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			String newHeapPtr = heapPtr + "+" + s0 + "+1";
			List<String> content = new ArrayList<String>();
			content.add(s0 + "=" + heapPtr);
			content.add(pdsInfo.heapIndex(heapPtr) + "=" + s0);
			content.add(heapPtr + "=" + newHeapPtr);
			
			String newHeapPtr_pair=heapPtr_pair+"+"+s0+"+1";
			List<String> content_pair=new ArrayList<String>();
			content_pair.add(s0+"="+heapPtr_pair);
			content_pair.add(pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),heapPtr_pair)
							 + "=" + s0);
			content_pair.add(heapPtr_pair+"="+newHeapPtr_pair);
			
			if (pdsInfo.checkForHeapOverflow()) {
				pdsStmt.addIf(ifStmt(newHeapPtr + ">" + pdsInfo.getHeapSize(), getOverflowCode(false),
									newHeapPtr_pair+">"+pdsInfo.getHeapSize(), getOverflowCode(true)));
				pdsStmt.addIf(elseStmt(content, content_pair));
			} else {				
				pdsStmt.addNext(content, content_pair);
			}
		} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
/*commented by suncong, don't consider twodims.
			int arrBits;
			if (absInst.getOpcode() == Opcodes.OPCODE_NEWARRAY
					&& immediateByte() == 4) {	// For boolean
				arrBits = 1;
			} else {
				arrBits = pdsMethod.getBitsAtPc(absInst.getOffset());
			}
			String s0TimesArrBits = "(" + s0 + "*" + arrBits + ")";
			String newHeapPtr1 = heapPtr + "+" + s0TimesArrBits + "/" + intBits
					+ "+2";
			String newHeapPtr2 = newHeapPtr1 + "+1";
			String s0ModIntBits = iremStmt(s0TimesArrBits, String.valueOf(intBits));
			String cond1 = s0ModIntBits + "==0";
			String cond2 = s0ModIntBits + "!=0";
			List<String> stmtList1 = new ArrayList<String>();
			List<String> stmtList2 = new ArrayList<String>();
			
			stmtList1.add(s0 + "=" + heapPtr);
			stmtList1.addAll(storeHeap(pdsInfo.getHeapName(), s0, intBits + "*" + heapPtr, intBits));
			stmtList1.addAll(storeHeap(pdsInfo.getHeapName(), arrBits, 
					intBits + "*" + heapPtr + "+" + intBits, intBits));
			stmtList2.addAll(stmtList1);
			stmtList1.add(heapPtr + "=" + newHeapPtr1);
			stmtList2.add(heapPtr + "=" + newHeapPtr2);
			
			if (pdsInfo.checkForHeapOverflow()) {
				
				int heapSize = pdsInfo.getStoredHeapSize();
				pdsStmt.addIf(addNewarrayStmt(cond1, newHeapPtr1 + ">" + heapSize, getOverflowCode()));
				pdsStmt.addIf(addNewarrayStmt(cond1, newHeapPtr1 + "<=" + heapSize, stmtList1));
				pdsStmt.addIf(addNewarrayStmt(cond2, newHeapPtr2 + ">" + heapSize, getOverflowCode()));
				pdsStmt.addIf(addNewarrayStmt(cond2, newHeapPtr2 + "<=" + heapSize, stmtList2));
			} else {
				
				pdsStmt.addIf(ifStmt(cond1, stmtList1));
				pdsStmt.addIf(ifStmt(cond2, stmtList2));
			}*/
		}
	}
	public void newarrayInstForParam(){
		int intBits = pdsInfo.getBits();
		String s0 = pdsInfo.stackIndex(0);
		String s0t=pdsInfo.generateTLabel(pdsInfo.stackIndex(0));
		String heapPtr = pdsInfo.getHeapPtrName();
		String heapPtr_p=pdsInfo.generateTLabel(heapPtr);//
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			String newHeapPtr = heapPtr + "+" + s0 + "+1";
			List<String> content = new ArrayList<String>();
			content.add(s0 + "=" + heapPtr);
			content.add(pdsInfo.heapIndex(heapPtr) + "=" + s0);
			content.add(heapPtr + "=" + newHeapPtr);
			
			String newHeapPtr_p=heapPtr_p+"+"+s0t+"+1";
			List<String> content_pair=new ArrayList<String>();
			content_pair.add(s0t+"="+heapPtr_p);
			content_pair.add(pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),heapPtr_p)
							 + "=" + s0t);
			content_pair.add(heapPtr_p+"="+newHeapPtr_p);
			
			content.addAll(content_pair);
			content_pair.clear();
			
			if (pdsInfo.checkForHeapOverflow()) {
				pdsStmt.addIf(ifStmt(newHeapPtr+">"+pdsInfo.getHeapSize()+"||"
					+newHeapPtr_p+">"+pdsInfo.getHeapSize(),getOverflowCode(false),"",""));
				pdsStmt.addIf(elseStmt(content, content_pair));
			} else {				
				pdsStmt.addNext(content, content_pair);
			}
		} else { // if (pdsInfo.getHeapOption() == HeapOption.TWODIMS)
		}
	}
	
	/**
	 * Adds the following if-stmt to pdsStmt:
	 * 		:: cond1 && cond2 -> stmt;
	 * 
	 * @param cond
	 * @param newHeapPtr
	 * @param op
	 * @param stmt
	 */
	public static TwoLists addNewarrayStmt(String cond1, String cond2, String stmt,
											String cond1_pair, String cond2_pair, String stmt_pair) {
		ArrayList<String> stmtList = new ArrayList<String>();
		stmtList.add(stmt);
		ArrayList<String> stmtListPair=new ArrayList<String>();
		stmtListPair.add(stmt_pair);
		return addNewarrayStmt(cond1, cond2, stmtList, cond1_pair, cond2_pair, stmtListPair);
	}
	
	public static TwoLists addNewarrayStmt(String cond1, String cond2, List<String> stmtList,
											String cond1_pair, String cond2_pair, List<String> stmtListPair) {
		ArrayList<String> condList = new ArrayList<String>();
		condList.add(cond1);
		condList.add(cond2);
		ArrayList<String> condListPair=new ArrayList<String>();
		condListPair.add(cond1_pair);
		condListPair.add(cond2_pair);
		
		return ifStmt(condList, stmtList, condListPair, stmtListPair);
		//pdsStmt.addIf(ifStmt(condList, stmtList));
	}

	private void oneInst(String content, String content_pair) {
		pdsStmt.addPar(content,content_pair);
	}
	/*by suncong, for initialMethodWrapper to insert a stack-irrelative instruction*/
	public void oneInstForInitWrapper(String content, String content_pair) {
		pdsStmt.addPar(content,content_pair);
	}
	
	private void popToInst(String var, String var_pair) {
		pdsStmt.addPar(popToStmt(var),popToStmt(var_pair));
	}
	/*by suncong, for array param preparation*/
	public void popToInstForArrayParam(String var1,String var2){
		List<String> tmpList=popToStmt(var1);
		tmpList.addAll(popToStmt2(var2));
		pdsStmt.addPar(tmpList,new ArrayList<String>());
	}
	private void popPushInst(String content, String content_pair, int pop, int push) {
		pdsStmt.addPar(popPushStmt(content, pop, push), popPushStmt(content_pair, pop, push));
	}
	
	private void pushWithInst(int content) {
		pushWithInst(String.valueOf(content),String.valueOf(content));
	}
	
	private void pushWithInst(String content, String content_pair) {
		pdsStmt.addPar(popPushStmt(content, 0, 1), popPushStmt(content_pair,0,1));
	}
	/********************/
	private void putfieldInst() throws InvalidByteCodeException {
		String[] fieldName = getReferencedName(pdsMethod.getClassFile(), absInst);
		if (pdsInfo.isIgnoredField(fieldName)) {
			popPushInst("undef","undef", 2, 0);
			return;
		}
//		System.out.println("%%putField <"+fieldName[0]+","+fieldName[1]+","+fieldName[2]+"> in "+pdsMethod.getFormattedName());
		String s0 = pdsInfo.stackIndex(0);
		String s1 = pdsInfo.stackIndex(1);
		DefaultMutableTreeNode thisNode = pdsInfo.getClassNode(fieldName[0]);
		Enumeration e = thisNode.breadthFirstEnumeration();
		DefaultMutableTreeNode subNode;
		String[] subName;
		String formattedSubName;
		String objType, objType_pair;
		int fieldIndex;
		String h, h_pair;
		List<String> cond, stmt, cond_pair, stmt_pair;
		int intBits = pdsInfo.getBits();
		
		if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
			objType = pdsInfo.heapIndex(s1);
			objType_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),s1);
		} else {	// pdsInfo.getHeapOption() == HeapOption.TWODIMS
			objType = loadHeap(pdsInfo.getHeapName(), intBits + "*" + s1, intBits);
			objType_pair=loadHeap(pdsInfo.generateTLabel(pdsInfo.getHeapName()), intBits+"*"+s1, intBits);
		}
		
		while (e.hasMoreElements()) {
			subNode = (DefaultMutableTreeNode) e.nextElement();
			subName = replaceClassName(fieldName, (String) subNode.getUserObject());
			formattedSubName = PDSField.formatFieldName(subName);
			fieldIndex = pdsInfo.indexOfField(formattedSubName);
			if (fieldIndex >= 0) {
				cond = new ArrayList<String>();
				cond.add(objType + "==" + pdsInfo.getClassIndex(subName[0]));
				cond_pair=new ArrayList<String>();
				cond_pair.add(objType_pair+"=="+pdsInfo.getClassIndex(subName[0]));
				
				if (pdsInfo.checkForNullPointerExceptions()) {
					cond.add(s1 + "!=0");
					cond_pair.add(s1+"!=0");
				}
				
				if (pdsInfo.getHeapOption() == HeapOption.SIMPLE) {
					h = pdsInfo.heapIndex(s1 + "+" + fieldIndex + "+" + 1);
					h_pair=pdsInfo.stringIndex(pdsInfo.generateTLabel(pdsInfo.getHeapName()),
												s1+"+"+fieldIndex+"+"+1);
					stmt = new ArrayList<String>();
					stmt.add(h + "=" + s0);
					stmt_pair=new ArrayList<String>();
					stmt_pair.add(h_pair+"="+s0);
				} else {	// pdsInfo.getHeapOption() == HeapOption.TWODIMS
					int fieldBits = pdsInfo.getFieldBits(formattedSubName);
					stmt = storeHeap(pdsInfo.getHeapName(),
							s0, intBits + "*" + s1 + "+" + intBits + "+" + fieldIndex, fieldBits);
					stmt_pair=storeHeap(pdsInfo.generateTLabel(pdsInfo.getHeapName()),
							s0, intBits + "*" + s1 + "+" + intBits + "+" + fieldIndex, fieldBits);					
				}
				pdsStmt.addIf(ifStmt(cond, popPushStmt(stmt, 2, 0),
									cond_pair, popPushStmt(stmt_pair,2,0)));
			}
		}
		
		if (pdsInfo.checkForNullPointerExceptions()) {
			pdsStmt.addIf(ifStmt(s1 + "==0", getNPECode(false),
								s1+"==0", getNPECode(true)));
		}
	}
	
	private void putstaticInst() throws InvalidByteCodeException {
		String[] fieldName = getReferencedName(pdsMethod.getClassFile(), absInst);
		if (pdsInfo.isIgnoredField(fieldName)) {
			popPushInst("undef","undef", 1, 0);
		} else {
			String tmp=PDSField.formatFieldName(fieldName);
			popToInst(tmp, pdsInfo.generatePairLabel(tmp,""));
		}
	}
	
	private void retInst() {
		
//		type = IF_INST;
		
		/*TODO*/
	}
	
	private void tableswitchInst() {
		
		TableSwitchInstruction tsInst = (TableSwitchInstruction) absInst;
		int offset = tsInst.getOffset();
		int[] jumpOffsets = tsInst.getJumpOffsets();
		int lowByte = tsInst.getLowByte();
		int highByte = tsInst.getHighByte();
		int target;
		String s0 = pdsInfo.stackIndex(0);
		String methodName = pdsMethod.getFormattedName();
		String methodName_pair=pdsInfo.generatePairLabel(methodName,"");
		String cond, cond_pair;
		List<String> stmt, stmt_pair;
		
		for (int i = 0; i <= (highByte - lowByte); i++) {
			target = offset + jumpOffsets[i];
			cond = s0 + "==" + String.valueOf(lowByte + i);
			stmt = popPushStmt(gotoStmt(methodName + target), 1, 0);
			stmt_pair=popPushStmt(gotoStmt(methodName_pair+target),1,0);
			pdsStmt.addIf(ifStmt(cond, stmt, cond, stmt_pair));
		}
		target = offset + tsInst.getDefaultOffset();
		stmt = popPushStmt(gotoStmt(methodName + target), 1, 0);
		stmt_pair=popPushStmt(gotoStmt(methodName_pair+target),1,0);
		pdsStmt.addIf(elseStmt(stmt, stmt_pair));
	}
	
	/*******************************************************************/
	/**                EXTERNAL UTILITIY FUNCTIONS                    **/
	/*******************************************************************/
	
	/**
	 * Returns name of class in <code>new</code> instruction.
	 *
	 * @param classFile the jclasslib class file.
	 * @param inst the <code>new</code> instruction.
	 * @return the class name.
	 */
	public static String getNewedClassName(ClassFile cFile, 
			AbstractInstruction aInst) throws InvalidByteCodeException {
		
		ImmediateShortInstruction isInst = (ImmediateShortInstruction) aInst;
		ConstantClassInfo ccInfo = 
			(ConstantClassInfo) cFile.getConstantPoolEntry(
				isInst.getImmediateShort(), ConstantClassInfo.class);
				
		return ccInfo.getName();
	}
	
	/**
	 * Returns names of class and method and method's descriptor 
	 * in <code>invokevirtual</code>, <code>invokespecial</code>, 
	 * and <code>invokestatic</code> instruction.
	 *
	 * @param classFile the jclasslib class file.
	 * @param inst the <code>invokevirtual</code>, 
	 *				<code>invokespecial</code>, or <code>invokestatic</code>
	 *				instruction.
	 * @return array of string containing the class name at index 0,
	 *				 method name at index 1, and method descriptor at
	 *				 index 2.
	 */
	public static String[] getReferencedName(ClassFile cFile,
		AbstractInstruction aInst) throws InvalidByteCodeException {
			
		ImmediateShortInstruction isInst = (ImmediateShortInstruction) aInst;
		ConstantReference constRef = (ConstantReference) 
			cFile.getConstantPoolEntry(isInst.getImmediateShort(), 
					ConstantReference.class);
		ConstantClassInfo ccInfo = constRef.getClassInfo();
		ConstantNameAndTypeInfo cnatInfo = constRef.getNameAndTypeInfo();
		
		String[] invokedName = new String[3];
		invokedName[0] = ccInfo.getName();
		invokedName[1] = cnatInfo.getName();
		invokedName[2] = cnatInfo.getDescriptor();
		
		return invokedName;
	}
	
	/*******************************************************************/
	/**                INTERNAL UTILITIY FUNCTIONS                    **/
	/*******************************************************************/
	
	private String branchTarget(boolean bPair) {
		
		BranchInstruction branchInst = (BranchInstruction) absInst;
		int target = branchInst.getOffset() + branchInst.getBranchOffset();
		String methodName = bPair? pdsInfo.generatePairLabel(pdsMethod.getFormattedName(),"") :
							pdsMethod.getFormattedName();
		
		return (target == 0) ? methodName :  methodName + String.valueOf(target);
	}
/*	private String branchTargetPair(){
		BranchInstruction branchInst = (BranchInstruction) absInst;
		int target = branchInst.getOffset() + branchInst.getBranchOffset();
		String methodName_pair = pdsInfo.generatePairLabel(pdsMethod.getFormattedName(),"");
		
		return (target == 0) ? methodName_pair :  methodName_pair + String.valueOf(target);
	}*/
	
	private String[] calleeInterfaceName() throws InvalidByteCodeException {
		
		InvokeInterfaceInstruction iiInst = (InvokeInterfaceInstruction) absInst;
		ConstantInterfaceMethodrefInfo cimInfo = 
				(ConstantInterfaceMethodrefInfo) 
				pdsMethod.getClassFile().getConstantPoolEntry(
				iiInst.getImmediateShort(), ConstantInterfaceMethodrefInfo.class);
		ConstantClassInfo ccInfo = cimInfo.getClassInfo();
		ConstantNameAndTypeInfo cnatInfo = cimInfo.getNameAndTypeInfo();
		
		String[] out = new String[3];
		out[0] = ccInfo.getName();
		out[1] = cnatInfo.getName();
		out[2] = cnatInfo.getDescriptor();
		
		return out;
	}
//done////////////////////////////////////////////////////////////////////////////
	public static int countBlocks(int totalBits, int intBits) {
		
		return (int) Math.ceil(((double) totalBits) / ((double) intBits));
	}
	
	/**
	 * Returns statements that handle the case of an exception. 
	 * @param targetLabel the label the code jumps to and which is used as a prefix
	 * @return
	 */
	public String getExceptionCode(String targetLabel, boolean bPair)
	{
		StringBuilder overflow = new StringBuilder("skip;\n\t   ");
		overflow.append(targetLabel).append(getLabel(bPair));
		overflow.append(":\t");
		overflow.append(gotoStmt(targetLabel));
		return overflow.toString();
	}
	
	/**
	 * Returns statements that handle the case of a Remopla StringBuilder overflow.
	 * @return
	 */
	public String getStringBuilderOverflowCode(boolean bPair)
	{
		return getExceptionCode(pdsInfo.getLabelStringBuilderOverflow(),bPair);
	}
	
	/**
	 * Returns statements that handle the case of a Remopla heap overflow.
	 * @return
	 */
	public String getOverflowCode(boolean bPair)
	{
		return getExceptionCode(pdsInfo.getLabelHeapOverflow(),bPair);
	}
	
	/**
	 * Returns statements that handle the case of referencing a null pointer. 
	 * @return
	 */
	public String getNPECode(boolean bPair)
	{
		return getExceptionCode(pdsInfo.getLabelNPE(),bPair);
	}
	
	/**
	 * Returns statements that handle the case of accessing an array beyond its size.
	 * @return
	 */
	public String getIOOBCode(boolean bPair)
	{
		return getExceptionCode(pdsInfo.getLabelIndexOutOfBounds(),bPair);
	}
	
	/**
	 * Returns a string representing integer value of heap at ptr with
	 * size bits. For example, if bits = 3, the method will
	 * return: ((heap[ptr+0]<<2) + (heap[ptr+1]<<1) + (heap[ptr+2])).
	 * 
	 * @param ptr
	 * @param bits
	 * @return
	 */
	public static String loadHeap(String heapName, String ptr, int bits) {
		
		StringBuilder b = new StringBuilder();
		String index;
		
		if (bits > 1) b.append("(");
		for (int i = bits-1; i > 0; i--) {
			b.append("(");
			index = ptr + "+" + String.valueOf(bits - i - 1);
			b.append(PDSInfo.stringIndex(heapName, index)
					+ "<<" + String.valueOf(i));
			b.append(")");
			b.append(" + ");
		}
		index = ptr + "+" + String.valueOf(bits - 1);
		b.append(PDSInfo.stringIndex(heapName, index));
		if (bits > 1) b. append(")");
		
		return b.toString();
	}
	
	/**
	 * For PDSInfo.HeapOption.TWODIMS: stores cont to heap starting at 
	 * ptr with size bits. For example, if bits = 4 and cont = 5, 
	 * the method will return a list of: heap[ptr] = 0, 
	 * heap[ptr+1] = 1, heap[ptr+2] = 0, heap[ptr+2] = 1.
	 * 
	 * @param cont
	 * @param ptr
	 * @param bits
	 * @return
	 */
	public static List<String> storeHeap(String heapName, int cont, 
			String ptr, int bits) {
		
		String bin = Integer.toBinaryString(cont);
		List<String> out = new ArrayList<String>();
		char b;
		
		for (int i = 0; i < bits; i++) {
			
			if (i < bits - bin.length()) {
				b = '0';
			} else {
				b = bin.charAt(i - bits + bin.length());
			}
			out.add(PDSInfo.stringIndex(heapName, ptr + "+" + i) + "=" + b);
		}
		
		return out;
	}
	
	/**
	 * For PDSInfo.HeapOption.TWODIMS: stores cont to heap starting at 
	 * ptr with size bits. For example, if bits = 4, the method will
	 * return a list of: heap[ptr] = cont/8, 
	 * heap[ptr+1] = ((cont<<1) - 15*(cont/8))/8,
	 * heap[ptr+2] = ((cont<<2) - 15*((cont<<1)/8))/8,
	 * heap[ptr+3] = ((cont<<3) - 15*((cont<<2)/8))/8.
	 * 
	 * @param cont
	 * @param ptr
	 * @param bits
	 * @return
	 */
	public static List<String> storeHeap(String heapName, String cont, 
			String ptr, int bits) {
		
		int c = (int) Math.pow(2, bits-1);
		int max = (int) Math.pow(2, bits) - 1;
		List<String> out = new ArrayList<String>();
		
		out.add(PDSInfo.stringIndex(heapName, ptr) + "=" + cont + "/" + c);
		
		for (int i = 1; i < bits; i++) {
			
			StringBuilder rhs = new StringBuilder();
			rhs.append("((");
			rhs.append(cont);
			rhs.append("<<");
			rhs.append(i);
			rhs.append(") - ");
			rhs.append(max);
			rhs.append("*(");
			if (i == 1) {
				rhs.append(cont);
			} else {
				rhs.append("(");
				rhs.append(cont);
				rhs.append("<<");
				rhs.append(i-1);
				rhs.append(")");
			}
			rhs.append("/");
			rhs.append(c);
			rhs.append("))/");
			rhs.append(c);
			
			out.add(PDSInfo.stringIndex(heapName, ptr + "+" + i) + "=" + rhs.toString());
		}
		
		return out;
	}
	
	public static TwoLists elseStmt(String stmt, String stmt_pair) {		
		return ifStmt("else", stmt, "else", stmt_pair);
	}
	
	public static TwoLists elseStmt(List<String> stmtList, List<String> stmt_pairList) {		
		return ifStmt("else", stmtList, "else", stmt_pairList);
	}
	
	private String gotoStmt(boolean bPair) {
		return "goto " + branchTarget(bPair);
	}
/*	private String gotoStmtPair(){
		return "goto "+branchTargetPair();
	}*/
	
	public static String gotoStmt(String target) {
		return "goto " + target;
	}
	
	public void gotoStmtForStubGen(String str1,String str2){
		oneInst(gotoStmt(str1),gotoStmt(str2));
	}
	
	public static TwoLists ifStmt(String cond, String stmt, String cond_pair, String stmt_pair) {
		
		List<String> condList = new ArrayList<String>();
		condList.add(cond);
		List<String> stmtList = new ArrayList<String>();
		stmtList.add(stmt);

		List<String> cond_pairList=new ArrayList<String>();
		cond_pairList.add(cond_pair);
		List<String> stmt_pairList=new ArrayList<String>();
		stmt_pairList.add(stmt_pair);
		
		return ifStmt(condList, stmtList, cond_pairList, stmt_pairList);
	}
	
	public static TwoLists ifStmt(String cond, List<String> stmtList, String cond_pair, List<String> stmt_pairList) {
		List<String> condList = new ArrayList<String>();
		condList.add(cond);
		List<String> cond_pairList=new ArrayList<String>();
		cond_pairList.add(cond_pair);
		
		return ifStmt(condList, stmtList, cond_pairList, stmt_pairList);
	}
	
	public static TwoLists ifStmt(List<String> condList, List<String> stmtList, List<String> cond_pairList,	List<String> stmt_pairList) {
		return new TwoLists(condList, stmtList, cond_pairList, stmt_pairList);
	}
	
	public int immediateByte() {
		
		return ((ImmediateByteInstruction) absInst).getImmediateByte();
	}
	
	/**
	 * Returns a string representing a%b
	 * 
	 * @param a
	 * @param b
	 * @return a - (b*(a/b))
	 */
	public static String iremStmt(String a, String b) {
		
		return a + "-(" + b + "*(" + a + "/" + b + "))";
	}
	
	private String paramList(int paramCount) {
		
		if (paramCount == 0) {
			return "()";
		}
		
		StringBuffer param = new StringBuffer();
		
		param.append("(");
		param.append(pdsInfo.stackIndex(paramCount - 1));
		for (int i = paramCount - 2; i >= 0; i--) {
			param.append(", ");
			param.append(pdsInfo.stackIndex(i));
		}
		param.append(")");
		
		return param.toString();
	}

/***************added for self-composing initial wrapper, stack renamed***************/
	public List<String> popPushStmt2(String action, int pop, int push) {
		
		ArrayList<String> actions = new ArrayList<String>();
		actions.add(action);
		
		return popPushStmt2(actions, pop, push);
	}

	public List<String> popPushStmt2(List<String> actions, int pop, int push) {
		
		ArrayList<String> list = new ArrayList<String>();
		
		if ((pop == 0) && (push == 0)) {
			if (actions.get(0).equals("undef") || actions.get(0).equals("!=0")) 
				list.add("skip");
			else
				list.addAll(actions);
		} else if ((pop == 0) && (push == 1)) {
			if (actions.get(0).equals("!=0"))
				list.add(pdsInfo.stackIndex(0)+pdsInfo.getTTail()+ "!=0");
			else
				list.add(pdsInfo.stackIndex(0)+pdsInfo.getTTail()+ "=" + actions.get(0));
			list.addAll(pushStmt2(1, 1));
		} else if ((pop == 1) && (push == 1)) {
			if (actions.get(0).equals("!=0"))
				list.add(pdsInfo.stackIndex(0)+pdsInfo.getTTail()+ "!=0");
			else
				list.add(pdsInfo.stackIndex(0)+pdsInfo.getTTail()+ "=" + actions.get(0));
		} else if (push == 0) {
			if (!actions.get(0).equals("undef") && !actions.get(0).equals("!=0"))
				list.addAll(actions);
			list.addAll(popStmt2(pop, pop));
		} else {	// if (push == 1)
			if (actions.get(0).equals("!=0"))
				list.add(pdsInfo.stackIndex(0)+pdsInfo.getTTail()+ "!=0");
			else
				list.add(pdsInfo.stackIndex(0)+pdsInfo.getTTail()+ "=" + actions.get(0));
			list.addAll(popStmt2(pop, pop - 1));
		}
		
		return list;
	}

	public List<String> pushStmt2(int from, int step) {
		
		ArrayList<String> list = new ArrayList<String>();
		for (int i = from; i < pdsMethod.getMaxStack(); i++) {
			list.add(stackEqual2(i, i - step));
		}
		
		return list;
	}

	public List<String> popToStmt2(String var) {
		return popPushStmt2(var + "=" + pdsInfo.generateTLabel(pdsInfo.stackIndex(0)), 1, 0);
	}
	public String stackEqual2(int left, int right) {
		StringBuilder out = new StringBuilder();
		
		out.append(pdsInfo.stackIndex(left)+pdsInfo.getTTail());
		out.append("=");
		out.append(pdsInfo.stackIndex(right)+pdsInfo.getTTail());
		
		return out.toString();
	}

	public List<String> popStmt2(int from, int step) {
		
		ArrayList<String> list = new ArrayList<String>();
		
		for (int i = from; i < pdsMethod.getMaxStack(); i++) {
			list.add(stackEqual2(i - step, i));
		}
		
		return list;
	}

	public void pushWithInstForInitWrapper(String content, String content_pair) {
		pdsStmt.addPar(popPushStmt(content, 0, 1), popPushStmt2(content_pair,0,1));
	}
	public void pushWithInstForInitWrapper2(String content,String content2){
		List<String> tmp=popPushStmt(content,0,1);
		tmp.addAll(popPushStmt2(content2,0,1));
		pdsStmt.addPar(tmp,new ArrayList<String>());
	}
	
	public void invokespecialInstForInitWrapper() throws InvalidByteCodeException {
		String[] calledName = getReferencedName(pdsMethod.getClassFile(), absInst);
		int paramCount = PDSMethod.countParam(calledName[2]) + 1;
		int retCount = PDSMethod.isVoid(calledName[2]) ? 0 : 1;
		
		if (calledName[0].equals("java/lang/AssertionError") && calledName[1].equals("<init>")) {
			oneInst(gotoStmt(pdsInfo.getLabelAssertError()), gotoStmt(pdsInfo.getLabelAssertError()));
			return;
		}
		
		if (PDSString.isInvokespecialStringBuilder(calledName)) {
			
			pdsStmt = PDSString.invokespecialStringBuilder(pdsInfo, pdsMethod, this, calledName);
			if (!pdsStmt.isEmpty()) return;
		}
		
		if (!pdsInfo.isIncludedMethod(calledName)) {
			logger.debug("\tnot included method, paramCount=" + paramCount + ", retCount=" + retCount);
			if (pdsInfo.checkForNullPointerExceptions()) {
				popPushInst("!=0","!=0", paramCount, retCount);
			} else {
				popPushInst("undef","undef", paramCount, retCount);
			}
			return;
		}
		
		String calledMethodName = PDSMethod.formatMethodName(calledName);
		String calledMethodName_pair=pdsInfo.generatePairLabel(calledMethodName,"");//
		String param = paramList(paramCount);
		String param_pair=paramList2(paramCount);
		if (pdsInfo.checkForNullPointerExceptions()) {
			pdsStmt.addIf(ifStmt(pdsInfo.stackIndex(paramCount - 1) + "==0", getNPECode(false),
							pdsInfo.stackIndex(paramCount - 1) + pdsInfo.getTTail()+ "==0", getNPECode(true)));
			pdsStmt.addIf(elseStmt(popPushStmt(calledMethodName + param, paramCount, retCount),
								popPushStmt2(calledMethodName_pair + param_pair, paramCount, retCount)));
		} else {
			popPushInst2(calledMethodName + param, calledMethodName_pair + param_pair, paramCount, retCount);
		}
	}

	private String paramList2(int paramCount) {
		
		if (paramCount == 0) {
			return "()";
		}
		
		StringBuffer param = new StringBuffer();
		
		param.append("(");
		param.append(pdsInfo.stackIndex(paramCount - 1)+pdsInfo.getTTail());
		for (int i = paramCount - 2; i >= 0; i--) {
			param.append(", ");
			param.append(pdsInfo.stackIndex(i)+pdsInfo.getTTail());
		}
		param.append(")");
		
		return param.toString();
	}
	private void popPushInst2(String content, String content_pair, int pop, int push) {
		pdsStmt.addPar(popPushStmt(content, pop, push), popPushStmt2(content_pair, pop, push));
	}

/***********************************************************/
	
	public List<String> popToStmt(String var) {
		
		return popPushStmt(var + "=" + pdsInfo.stackIndex(0), 1, 0);
	}
	
	public List<String> popStmt(int from, int step) {
		
		ArrayList<String> list = new ArrayList<String>();
		
		for (int i = from; i < pdsMethod.getMaxStack(); i++) {
			list.add(stackEqual(i - step, i));
		}
		
		return list;
	}
	
	public List<String> popPushStmt(String action, int pop, int push) {
		
		ArrayList<String> actions = new ArrayList<String>();
		actions.add(action);
		
		return popPushStmt(actions, pop, push);
	}
	
	public List<String> popPushStmt(List<String> actions, int pop, int push) {
		
		ArrayList<String> list = new ArrayList<String>();
		
		if ((pop == 0) && (push == 0)) {
			if (actions.get(0).equals("undef") || actions.get(0).equals("!=0")) 
				list.add("skip");
			else
				list.addAll(actions);
		} else if ((pop == 0) && (push == 1)) {
			if (actions.get(0).equals("!=0"))
				list.add(pdsInfo.stackIndex(0) + "!=0");
			else
				list.add(pdsInfo.stackIndex(0) + "=" + actions.get(0));
			list.addAll(pushStmt(1, 1));
		} else if ((pop == 1) && (push == 1)) {
			if (actions.get(0).equals("!=0"))
				list.add(pdsInfo.stackIndex(0) + "!=0");
			else
				list.add(pdsInfo.stackIndex(0) + "=" + actions.get(0));
		} else if (push == 0) {
			if (!actions.get(0).equals("undef")
					&& !actions.get(0).equals("!=0"))
				list.addAll(actions);
			list.addAll(popStmt(pop, pop));
		} else {	// if (push == 1)
			if (actions.get(0).equals("!=0"))
				list.add(pdsInfo.stackIndex(0) + "!=0");
			else
				list.add(pdsInfo.stackIndex(0) + "=" + actions.get(0));
			list.addAll(popStmt(pop, pop - 1));
		}
		
		return list;
	}

	public List<String> pushStmt(int from, int step) {
		
		ArrayList<String> list = new ArrayList<String>();
		for (int i = from; i < pdsMethod.getMaxStack(); i++) {
			list.add(stackEqual(i, i - step));
		}
		
		return list;
	}
	
	/**
	 * Replaces the first element of array names with name
	 * 
	 * @param names
	 * @param name
	 * @return
	 */
	private static String[] replaceClassName(String[] names, String name) {
		
		String[] newNames = new String[names.length];
		newNames[0] = name;
		newNames[1] = names[1];
		if (names.length == 3) {
			newNames[2] = names[2];
		}
		
		return newNames;
	}
	
	/**
	 * Constructs a string representing:
	 * 		s0 = s1 op s0
	 * 
	 * @param op
	 * @return
	 */
	public String stackArith(String op) {
		
		StringBuilder out = new StringBuilder();
		
		out.append(pdsInfo.stackIndex(0));
		out.append("=");
		out.append(pdsInfo.stackIndex(1));
		out.append(op);
		out.append(pdsInfo.stackIndex(0));
		
		return out.toString();
	}
	
	/**
	 * Construct a string representing:
	 * 		pdsInfo.stackIndex(left) = pdsInfo.stackIndex(right)
	 * 
	 * @param left
	 * @param right
	 * @return
	 */
	public String stackEqual(int left, int right) {
		
		StringBuilder out = new StringBuilder();
		
		out.append(pdsInfo.stackIndex(left));
		out.append("=");
		out.append(pdsInfo.stackIndex(right));
		
		return out.toString();
	}
}
